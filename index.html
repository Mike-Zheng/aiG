<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <meta name="theme-color" content="#37383C" />
    <link rel="manifest" href="manifest.json" />
    <link rel="apple-touch-icon" href="icon-192.png" />
    <title>aiG</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        background: #37383c;
        padding: 20px;
        line-height: 1.6;
        padding-bottom: 80px;
        min-height: 100vh;
      }

      .upload-section {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100vh;
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 100;
      }

      .file-input-wrapper {
        position: relative;
        display: inline-block;
      }

      .file-input-wrapper input[type="file"] {
        position: absolute;
        opacity: 0;
        width: 0;
        height: 0;
      }

      .upload-btn {
        display: inline-block;
        padding: 8px 24px;
        background: #4a4b50;
        color: white;
        border-radius: 5px;
        font-size: 10px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .upload-btn:hover {
        background: rgba(255, 255, 255, 0.15);
        transform: translateY(-2px);
      }

      .upload-btn:active {
        transform: translateY(0);
      }

      .destroy-btn {
        position: fixed;
        top: 10px;
        left: 5px;
        padding: 5px 24px;
        background: #4a4b50;
        color: #fff;
        border: none;
        border-radius: 2px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        z-index: 1000;
        display: none;
        backdrop-filter: blur(10px);
      }

      .destroy-btn:hover {
        background: rgba(255, 100, 100, 0.3);
        transform: scale(1.05);
      }

      .destroy-btn:active {
        transform: scale(0.95);
      }

      .destroy-btn.visible {
        display: block;
        animation: fadeIn 0.3s ease-out;
      }

      .loading {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100vh;
        align-items: center;
        justify-content: center;
        z-index: 100;
        display: flex;
        cursor: pointer;
      }

      .loading-spinner {
        width: 50px;
        height: 50px;
        margin: 0 auto 20px;
        border: 4px solid rgba(255, 255, 255, 0.1);
        border-top: 4px solid rgba(255, 255, 255, 0.4);
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @keyframes scaleIn {
        from {
          opacity: 0;
          transform: scale(0.9);
        }
        to {
          opacity: 1;
          transform: scale(1);
        }
      }

      #gallery {
        position: relative;
        width: 100%;
        margin-top: 50px;
        min-height: 100vh;
      }

      .gallery-row {
        position: absolute;
        display: flex;
        gap: 5px;
        width: 100%;
      }

      .gallery-item {
        border-radius: 3px;
        overflow: hidden;
        border: 1px solid rgba(255, 255, 255, 0.1);
        transition: all 0.3s ease;
        position: relative;
        animation: fadeIn 0.5s ease-out backwards;
        cursor: pointer;
        touch-action: manipulation; /* ç¦ç”¨é›™æ“Šç¸®æ”¾ï¼ŒåŠ é€Ÿé›™æ“ŠéŸ¿æ‡‰ */
      }

      .gallery-item.placeholder {
        background: rgba(255, 255, 255, 0.02);
      }

      .gallery-item:nth-child(1) {
        animation-delay: 0.05s;
      }
      .gallery-item:nth-child(2) {
        animation-delay: 0.1s;
      }
      .gallery-item:nth-child(3) {
        animation-delay: 0.15s;
      }
      .gallery-item:nth-child(4) {
        animation-delay: 0.2s;
      }
      .gallery-item:nth-child(5) {
        animation-delay: 0.25s;
      }
      .gallery-item:nth-child(6) {
        animation-delay: 0.3s;
      }
      .gallery-item:nth-child(7) {
        animation-delay: 0.35s;
      }
      .gallery-item:nth-child(8) {
        animation-delay: 0.4s;
      }

      .gallery-item:hover {
        transform: translateY(-4px);
        border-color: rgba(255, 255, 255, 0.2);
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
      }

      .gallery-item img,
      .gallery-item video {
        width: 100%;
        height: auto;
        display: block;
        -webkit-user-select: none;
        user-select: none;
        cursor: pointer;
        transition: transform 0.3s ease;
        touch-action: manipulation; /* ç¦ç”¨é›™æ“Šç¸®æ”¾ï¼ŒåŠ é€Ÿé›™æ“ŠéŸ¿æ‡‰ */
      }

      .gallery-item video {
        display: none;
      }

      .gallery-item:hover img,
      .gallery-item:hover video {
        transform: scale(1.05);
      }

      .fullscreen-icon {
        position: absolute;
        bottom: 5px;
        right: 5px;
        width: 30px;
        height: 30px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
        z-index: 10;
        backdrop-filter: blur(10px);
      }

      .fullscreen-icon:hover {
        background: rgba(0, 0, 0, 0.8);
        transform: scale(1.1);
        border-color: rgba(255, 255, 255, 0.4);
      }

      .fullscreen-icon svg {
        width: 20px;
        height: 20px;
        fill: white;
      }

      .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.95);
        z-index: 9999;
        align-items: center;
        justify-content: center;
        animation: fadeIn 0.3s ease-out;
      }

      .modal.active {
        display: flex;
      }

      .modal-content {
        position: relative;
        max-width: 90vw;
        max-height: 90vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        animation: scaleIn 0.4s ease-out;
      }

      .modal-content img {
        max-width: 100%;
        max-height: 90vh;
        object-fit: contain;
      }

      .modal-close {
        position: absolute;
        top: 20px;
        right: 20px;
        width: 50px;
        height: 50px;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        color: white;
        font-size: 24px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
        z-index: 10000;
      }

      .modal-close:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: rotate(90deg);
      }

      .error {
        background: rgba(255, 100, 100, 0.1);
        border: 2px solid rgba(255, 100, 100, 0.3);
        color: #ff6b6b;
        padding: 30px;
        border-radius: 12px;
        margin: 20px;
        max-width: 500px;
        text-align: center;
      }

      .error h3 {
        margin: 0 0 15px 0;
        font-size: 1.3em;
      }

      .error p {
        margin: 10px 0;
        line-height: 1.6;
      }

      .error code {
        background: rgba(255, 255, 255, 0.1);
        padding: 2px 6px;
        border-radius: 3px;
        font-family: monospace;
      }

      @media (max-width: 600px) {
        body {
          padding: 5px;
          padding-bottom: 60px;
        }

        #gallery {
          margin-top: 40px;
        }

        .gallery-row {
          gap: 3px;
        }

        .modal-content img {
          max-height: 90vh;
        }

        .modal-close {
          top: 10px;
          right: 10px;
          width: 40px;
          height: 40px;
          font-size: 20px;
        }
      }
    </style>
  </head>
  <body>
    <button class="destroy-btn" id="destroy-btn">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="16"
        height="16"
        viewBox="0 0 16 16"
      >
        <path
          fill="currentColor"
          fill-rule="evenodd"
          d="M5.75 3V1.5h4.5V3zm-1.5 0V1a1 1 0 0 1 1-1h5.5a1 1 0 0 1 1 1v2h2.5a.75.75 0 0 1 0 1.5h-.365l-.743 9.653A2 2 0 0 1 11.148 16H4.852a2 2 0 0 1-1.994-1.847L2.115 4.5H1.75a.75.75 0 0 1 0-1.5zm-.63 1.5h8.76l-.734 9.538a.5.5 0 0 1-.498.462H4.852a.5.5 0 0 1-.498-.462z"
          clip-rule="evenodd"
        />
      </svg>
    </button>

    <div class="upload-section" id="upload-section">
      <div class="file-input-wrapper">
        <input type="file" id="file-input" accept=".bin" />
        <label for="file-input" class="upload-btn">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="20"
            height="20"
            viewBox="0 0 24 24"
          >
            <path
              fill="currentColor"
              d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8zm4 18H6V4h7v5h5z"
            />
          </svg>
        </label>
      </div>
    </div>

    <div class="loading" id="loading">
      <div class="loading-spinner"></div>
    </div>

    <div id="gallery"></div>

    <div class="modal" id="modal">
      <div class="modal-close" id="modal-close">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="24"
          height="24"
          viewBox="0 0 24 24"
        >
          <g
            fill="none"
            stroke="currentColor"
            stroke-dasharray="22"
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="1"
          >
            <path d="M5 5l14 14">
              <animate
                fill="freeze"
                attributeName="stroke-dashoffset"
                dur="0.5s"
                values="22;0"
              />
            </path>
            <path stroke-dashoffset="22" d="M19 5l-14 14">
              <animate
                fill="freeze"
                attributeName="stroke-dashoffset"
                begin="0.5s"
                dur="0.5s"
                to="0"
              />
            </path>
          </g>
        </svg>
      </div>
      <div class="modal-content">
        <img id="modal-img" src="" alt="" style="display: none;" />
        <video id="modal-video" src="" loop autoplay muted playsinline style="display: none; max-width: 100%; max-height: 90vh;"></video>
      </div>
    </div>

    <script>
      // ==================== GalleryEngine æ ¸å¿ƒå¼•æ“ ====================
      class GalleryEngine {
        constructor(containerElement) {
          this.container = containerElement;
          this.buffer = null;
          this.indexMap = null;
          this.payloadStart = 0;

          // BIN æª”æ¡ˆç°½åé…ç½®ï¼ˆéœ€èˆ‡ scripts/bin-signature.json ä¿æŒä¸€è‡´ï¼‰
          this.signatureConfig = {
            secretKey: 'aiG-binary-package-secret-key-2026',
            magicNumber: 'aiG.BIN',
            version: '1.0.0',
            algorithm: 'SHA-256'
          };

          // ç‹€æ…‹ç®¡ç†
          this.thumbUrls = new Map();
          this.activeState = {
            id: null,
            element: null,
            animUrl: null,
            type: null,
          };

          // é»æ“Šå»¶è¿Ÿè¨ˆæ™‚å™¨ï¼ˆé˜²æ­¢å–®æ“Šå’Œé›™æ“Šè¡çªï¼‰
          this.clickTimer = null;
          this.clickDelay = 250; // 250ms å»¶é²

          // ç§»å‹•è¨­å‚™é›™æ“Šæª¢æ¸¬
          this.lastTapTime = 0;
          this.lastTapTarget = null;
          this.doubleTapDelay = 300; // 300ms å…§è¦–ç‚ºé›™æ“Š
          this.justDoubleTapped = false; // æ¨™è¨˜æ˜¯å¦å‰›å‰›é›™æ“Šï¼ˆé˜²æ­¢è§¸ç™¼å–®æ“Šï¼‰

          // Justified Row Layout é…ç½®ï¼ˆéŸ¿æ‡‰å¼èª¿æ•´ï¼‰
          const isMobile = window.innerWidth <= 600;
          this.targetRowHeight = isMobile ? 120 : 200; // ç›®æ¨™è¡Œé«˜ï¼ˆpxï¼‰ï¼šç§»å‹•ç«¯ 120pxï¼Œæ¡Œé¢ 200px
          this.rowGap = isMobile ? 3 : 5; // è¡Œé–“è·ï¼ˆpxï¼‰
          this.itemGap = isMobile ? 3 : 5; // é …ç›®é–“è·ï¼ˆpxï¼‰
          this.containerWidth = 0;

          // Virtual Scroller ç‹€æ…‹ï¼ˆè¡Œç´šåˆ¥ï¼‰
          this.allIds = [];
          this.rows = []; // è¡Œæ•¸æ“šï¼š{items: [{id, width, height}], height, top}
          this.renderedRows = new Map(); // rowIndex -> {element, isLoaded}
          this.renderedItems = new Map(); // id -> {element, isLoaded}
          this.loadedThumbs = new Set(); // å·²åŠ è¼‰çš„ç¸®åœ– ID

          // é›¢é–‹è¦–çª—è‡ªå‹•å›æ”¶æ©Ÿåˆ¶ (é˜² iOS å´©æ½°æ ¸å¿ƒ)
          this.animationObserver = new IntersectionObserver(
            (entries) => {
              entries.forEach((entry) => {
                if (
                  !entry.isIntersecting &&
                  entry.target === this.activeState.imgEl
                ) {
                  this.stopActiveAnimation();
                }
              });
            },
            { threshold: 0 },
          );

          // Virtual Scroller è§€å¯Ÿå™¨ - æŒ‰è¡Œç®¡ç†åœ–ç‰‡çš„åŠ è¼‰èˆ‡å¸è¼‰
          this.virtualObserver = new IntersectionObserver(
            (entries) => {
              entries.forEach((entry) => {
                const rowIndex = parseInt(entry.target.dataset.rowIndex);
                if (isNaN(rowIndex)) return;

                if (entry.isIntersecting) {
                  // é€²å…¥è¦–çª— - åŠ è¼‰é€™ä¸€è¡Œçš„æ‰€æœ‰ç¸®åœ–
                  this.loadRow(rowIndex, entry.target);
                } else {
                  // é›¢é–‹è¦–çª— - å¸è¼‰é€™ä¸€è¡Œçš„æ‰€æœ‰åœ–ç‰‡
                  this.unloadRow(rowIndex, entry.target);
                }
              });
            },
            {
              rootMargin: "400px", // æå‰ 400px é–‹å§‹åŠ è¼‰ï¼ˆè¡Œç´šåˆ¥éœ€è¦æ›´å¤§ç·©è¡ï¼‰
              threshold: 0,
            },
          );

          // ç¶å®šäº‹ä»¶ä»£ç†
          this.handleTap = this.handleTap.bind(this);
          this.handleDoubleTap = this.handleDoubleTap.bind(this);
          this.handleTouchEnd = this.handleTouchEnd.bind(this);
          
          this.container.addEventListener("click", this.handleTap);
          this.container.addEventListener("dblclick", this.handleDoubleTap);
          this.container.addEventListener("touchend", this.handleTouchEnd);
        }

        /**
         * é©—è­‰ BIN æª”æ¡ˆç°½å
         * @param {ArrayBuffer} buffer - BIN æª”æ¡ˆçš„ ArrayBuffer
         * @returns {Promise<Object>} é©—è­‰çµæœ {valid, magic, version, dataStartOffset}
         */
        async verifyBinFile(buffer) {
          const view = new DataView(buffer);
          let offset = 0;

          // æª¢æŸ¥æœ€å°æª”æ¡ˆå¤§å°
          if (buffer.byteLength < 28) {
            throw new Error('æª”æ¡ˆå¤§å°ä¸æ­£ç¢ºï¼Œå¯èƒ½ä¸æ˜¯æœ‰æ•ˆçš„ BIN æª”æ¡ˆ');
          }

          // 1. è®€å– Magic Number (8 bytes)
          const magicBytes = new Uint8Array(buffer, offset, 8);
          const magic = new TextDecoder().decode(magicBytes).replace(/\0/g, '');
          offset += 8;

          if (magic !== this.signatureConfig.magicNumber) {
            throw new Error(`ç„¡æ•ˆçš„æª”æ¡ˆæ ¼å¼ï¼é æœŸ: ${this.signatureConfig.magicNumber}, å¯¦éš›: ${magic}`);
          }

          // 2. è®€å– Version (16 bytes)
          const versionBytes = new Uint8Array(buffer, offset, 16);
          const version = new TextDecoder().decode(versionBytes).replace(/\0/g, '');
          offset += 16;

          console.log(`ğŸ“¦ BIN æª”æ¡ˆç‰ˆæœ¬: ${version}`);

          // 3. è®€å–ç°½åé•·åº¦ (4 bytes)
          const signatureLength = view.getUint32(offset, true);
          offset += 4;

          if (signatureLength <= 0 || signatureLength > 1024) {
            throw new Error(`ç°½åé•·åº¦ç•°å¸¸: ${signatureLength}`);
          }

          // 4. è®€å–å„²å­˜çš„ç°½å
          const storedSignature = new Uint8Array(buffer, offset, signatureLength);
          offset += signatureLength;

          // 5. å‰©é¤˜çš„è³‡æ–™å…§å®¹ï¼ˆç”¨æ–¼é©—è­‰ï¼‰
          const dataBuffer = buffer.slice(offset);
          const dataStartOffset = offset;

          // 6. ä½¿ç”¨ Web Crypto API è¨ˆç®— HMAC-SHA256
          console.log('ğŸ” æ­£åœ¨é©—è­‰æª”æ¡ˆç°½å...');
          const encoder = new TextEncoder();
          const keyData = encoder.encode(this.signatureConfig.secretKey);
          
          const cryptoKey = await crypto.subtle.importKey(
            'raw',
            keyData,
            { name: 'HMAC', hash: this.signatureConfig.algorithm },
            false,
            ['sign']
          );

          const calculatedSignature = await crypto.subtle.sign(
            'HMAC',
            cryptoKey,
            dataBuffer
          );

          // 7. æ¯”è¼ƒç°½å
          const calculated = new Uint8Array(calculatedSignature);
          
          if (calculated.length !== storedSignature.length) {
            throw new Error('ç°½åé©—è­‰å¤±æ•—ï¼æª”æ¡ˆå¯èƒ½å·²è¢«ç«„æ”¹æˆ–æå£');
          }

          for (let i = 0; i < calculated.length; i++) {
            if (calculated[i] !== storedSignature[i]) {
              throw new Error('ç°½åé©—è­‰å¤±æ•—ï¼æª”æ¡ˆå¯èƒ½å·²è¢«ç«„æ”¹æˆ–æå£');
            }
          }

          console.log('âœ… ç°½åé©—è­‰é€šé');

          return {
            valid: true,
            magic,
            version,
            dataStartOffset
          };
        }

        async loadFromFile(file) {
          console.log("ğŸ”„ æ­£åœ¨è¼‰å…¥è³‡æ–™åº«...");

          try {
            this.buffer = await file.arrayBuffer();

            // é©—è­‰ BIN æª”æ¡ˆï¼ˆåŒ…å« Magic Number å’Œç°½åæª¢æŸ¥ï¼‰
            const verifyResult = await this.verifyBinFile(this.buffer);
            
            if (!verifyResult.valid) {
              throw new Error('BIN æª”æ¡ˆé©—è­‰å¤±æ•—');
            }

            console.log(`ğŸ“‹ æª”æ¡ˆè³‡è¨Š: ${verifyResult.magic} v${verifyResult.version}`);

            // å¾é©—è­‰å¾Œçš„è³‡æ–™ä½ç½®é–‹å§‹è§£æ
            const dataView = new DataView(this.buffer, verifyResult.dataStartOffset);

            // è®€å– JSON ç´¢å¼•é•·åº¦ (4 bytes)
            const jsonLength = dataView.getUint32(0, true);

            // è§£æ JSON ç´¢å¼•
            const jsonStr = new TextDecoder().decode(
              new Uint8Array(this.buffer, verifyResult.dataStartOffset + 4, jsonLength),
            );
            this.indexMap = JSON.parse(jsonStr);

            // è¨ˆç®— Payload èµ·å§‹ä½ç½®ï¼ˆè³‡æ–™èµ·å§‹ + 4 bytes é•·åº¦ + JSON å…§å®¹ï¼‰
            this.payloadStart = verifyResult.dataStartOffset + 4 + jsonLength;

            console.log(
              `âœ… è¼‰å…¥å®Œæˆï¼šå…± ${Object.keys(this.indexMap).length} å€‹é …ç›®`,
            );
            console.log(
              `   è³‡æ–™å¤§å°ï¼š${(this.buffer.byteLength / 1024 / 1024).toFixed(2)} MB`,
            );

            // åˆå§‹åŒ–æ‰€æœ‰ç¸®åœ–
            this.initThumbnails();

            return this.indexMap;
          } catch (error) {
            console.error("âŒ è¼‰å…¥å¤±æ•—:", error);
            throw error;
          }
        }

        /**
         * è¨ˆç®— Justified Row Layout
         * å°‡æ‰€æœ‰åœ–ç‰‡æŒ‰è¡Œåˆ†çµ„ï¼Œç¢ºä¿æ¯è¡Œå¯¬åº¦å¡«æ»¿å®¹å™¨
         * ä½¿ç”¨æ™ºèƒ½åˆ†é…ç®—æ³•ï¼Œè®“æ¯è¡Œåœ–ç‰‡æ•¸é‡ç›¡å¯èƒ½æ¥è¿‘ï¼Œé¿å…æœ€å¾Œä¸€è¡Œéå°‘
         */
        calculateRows() {
          this.containerWidth = this.container.clientWidth || window.innerWidth - 40;
          const targetHeight = this.targetRowHeight;
          const gap = this.itemGap;
          
          // ===== ç¬¬ä¸€éšæ®µï¼šé ç®—è¡Œæ•¸å’Œå¹³å‡æ¯è¡Œé …ç›®æ•¸ =====
          let totalScaledWidth = 0;
          const scaledWidths = [];
          
          for (const id of this.allIds) {
            const meta = this.indexMap[id];
            if (!meta) continue;
            
            const aspectRatio = meta.width / meta.height;
            const scaledWidth = targetHeight * aspectRatio;
            scaledWidths.push({ id, scaledWidth, aspectRatio });
            totalScaledWidth += scaledWidth;
          }
          
          // ä¼°ç®—éœ€è¦çš„è¡Œæ•¸ï¼ˆè€ƒæ…®é–“è·ï¼‰
          const avgItemsPerRow = Math.round(this.containerWidth / (totalScaledWidth / scaledWidths.length));
          const estimatedRows = Math.ceil(scaledWidths.length / avgItemsPerRow);
          const targetItemsPerRow = Math.ceil(scaledWidths.length / estimatedRows);
          
          console.log(`ğŸ“Š é ç®—: ${scaledWidths.length} å€‹é …ç›®ï¼Œç´„ ${estimatedRows} è¡Œï¼Œç›®æ¨™æ¯è¡Œ ${targetItemsPerRow} å€‹`);
          
          // ===== ç¬¬äºŒéšæ®µï¼šå¯¦éš›åˆ†é…åˆ°å„è¡Œ =====
          const rows = [];
          let currentRowItems = [];
          let currentRowWidth = 0;
          let cumulativeY = 0;
          let processedCount = 0;

          for (let i = 0; i < scaledWidths.length; i++) {
            const item = scaledWidths[i];
            const remainingItems = scaledWidths.length - processedCount;
            const remainingRows = estimatedRows - rows.length;
            const shouldHaveInRow = Math.ceil(remainingItems / remainingRows);
            
            // è¨ˆç®—ç•¶å‰è¡Œçš„ç¸½é–“è·
            const totalGapsWidth = currentRowItems.length * gap;
            
            // åˆ¤æ–·æ˜¯å¦æ‡‰è©²æ›è¡Œï¼š
            // 1. åŠ å…¥é€™å¼µåœ–å¾Œè¶…éå®¹å™¨å¯¬åº¦
            // 2. ç•¶å‰è¡Œå·²é”åˆ°ç›®æ¨™æ•¸é‡
            const wouldOverflow = currentRowWidth + item.scaledWidth + totalGapsWidth > this.containerWidth;
            const reachedTarget = currentRowItems.length >= shouldHaveInRow;
            
            if (currentRowItems.length > 0 && (wouldOverflow || (reachedTarget && remainingRows > 1))) {
              // çµç®—ç•¶å‰è¡Œ
              const availableWidth = this.containerWidth - (currentRowItems.length - 1) * gap;
              const ratio = availableWidth / currentRowWidth;
              const finalRowHeight = targetHeight * ratio;

              rows.push({
                items: currentRowItems.map(rowItem => ({
                  id: rowItem.id,
                  width: rowItem.scaledWidth * ratio,
                  height: finalRowHeight,
                  aspectRatio: rowItem.aspectRatio
                })),
                height: finalRowHeight,
                top: cumulativeY
              });

              cumulativeY += (finalRowHeight + this.rowGap);
              processedCount += currentRowItems.length;

              // é–‹å§‹æ–°è¡Œ
              currentRowItems = [item];
              currentRowWidth = item.scaledWidth;
            } else {
              // ç¹¼çºŒæ·»åŠ åˆ°ç•¶å‰è¡Œ
              currentRowItems.push(item);
              currentRowWidth += item.scaledWidth;
            }
          }

          // è™•ç†æœ€å¾Œä¸€è¡Œï¼ˆåŒæ¨£å¡«æ»¿å®¹å™¨å¯¬åº¦ï¼‰
          if (currentRowItems.length > 0) {
            const availableWidth = this.containerWidth - (currentRowItems.length - 1) * gap;
            const ratio = availableWidth / currentRowWidth;
            const finalRowHeight = targetHeight * ratio;

            rows.push({
              items: currentRowItems.map(item => ({
                id: item.id,
                width: item.scaledWidth * ratio,
                height: finalRowHeight,
                aspectRatio: item.aspectRatio
              })),
              height: finalRowHeight,
              top: cumulativeY
            });
            
            cumulativeY += (finalRowHeight + this.rowGap);
          }

          this.rows = rows;
          console.log(`ğŸ“ Justified Layout: è¨ˆç®—å®Œæˆ ${rows.length} è¡Œï¼Œç¸½é«˜åº¦ ${cumulativeY}px`);
          
          // è¼¸å‡ºæ¯è¡Œçš„é …ç›®æ•¸ï¼Œæ–¹ä¾¿èª¿è©¦
          const itemCounts = rows.map(r => r.items.length).join(', ');
          console.log(`ğŸ“Š æ¯è¡Œé …ç›®æ•¸: [${itemCounts}]`);
          
          return rows;
        }

        initThumbnails() {
          console.log("ğŸ–¼ï¸  æº–å‚™ Justified Row Layout...");
          this.allIds = Object.keys(this.indexMap);
          
          // è¨ˆç®—è¡Œå¸ƒå±€
          this.calculateRows();
          
          console.log(
            `âœ… æº–å‚™å®Œæˆï¼šå…± ${this.allIds.length} å€‹é …ç›®ï¼Œåˆ†ç‚º ${this.rows.length} è¡Œ`,
          );
        }

        /**
         * åŠ è¼‰ä¸€æ•´è¡Œçš„æ‰€æœ‰ç¸®åœ–
         */
        loadRow(rowIndex, rowElement) {
          const row = this.rows[rowIndex];
          if (!row) return;

          row.items.forEach(item => {
            const id = item.id;
            if (this.loadedThumbs.has(id)) return;

            const meta = this.indexMap[id];
            if (!meta) return;

            const slice = this.buffer.slice(
              this.payloadStart + meta.thumb.offset,
              this.payloadStart + meta.thumb.offset + meta.thumb.length,
            );
            const thumbUrl = URL.createObjectURL(
              new Blob([slice], { type: "image/webp" }),
            );
            this.thumbUrls.set(id, thumbUrl);
            this.loadedThumbs.add(id);

            // æ›´æ–° DOM
            const itemElement = rowElement.querySelector(`[data-id="${id}"]`);
            const img = itemElement?.querySelector("img");
            if (img) {
              img.src = thumbUrl;
              itemElement.classList.remove("placeholder");
            }
          });

          console.log(`âœ… åŠ è¼‰ç¬¬ ${rowIndex} è¡Œ (${row.items.length} å€‹é …ç›®)`);
        }

        /**
         * å¸è¼‰ä¸€æ•´è¡Œçš„æ‰€æœ‰ç¸®åœ–
         */
        unloadRow(rowIndex, rowElement) {
          const row = this.rows[rowIndex];
          if (!row) return;

          let unloadedCount = 0;
          row.items.forEach(item => {
            const id = item.id;
            if (!this.loadedThumbs.has(id)) return;
            if (this.activeState.id === id) return; // æ­£åœ¨æ’­æ”¾çš„ä¸å¸è¼‰

            const thumbUrl = this.thumbUrls.get(id);
            if (thumbUrl) {
              URL.revokeObjectURL(thumbUrl);
              this.thumbUrls.delete(id);
            }
            this.loadedThumbs.delete(id);

            const itemElement = rowElement.querySelector(`[data-id="${id}"]`);
            const img = itemElement?.querySelector("img");
            if (img) {
              img.src = "";
              itemElement.classList.add("placeholder");
              unloadedCount++;
            }
          });

          if (unloadedCount > 0) {
            console.log(`ğŸ—‘ï¸  å¸è¼‰ç¬¬ ${rowIndex} è¡Œ (${unloadedCount} å€‹é …ç›®)`);
          }
        }

        loadThumbnail(id, itemElement) {
          if (this.loadedThumbs.has(id)) return; // å·²åŠ è¼‰

          const meta = this.indexMap[id];
          if (!meta) return;

          const slice = this.buffer.slice(
            this.payloadStart + meta.thumb.offset,
            this.payloadStart + meta.thumb.offset + meta.thumb.length,
          );
          const thumbUrl = URL.createObjectURL(
            new Blob([slice], { type: "image/webp" }),
          );
          this.thumbUrls.set(id, thumbUrl);
          this.loadedThumbs.add(id);

          // æ›´æ–° DOM
          const img = itemElement.querySelector("img");
          if (img) {
            img.src = thumbUrl;
            itemElement.classList.remove("placeholder");
            console.log(`âœ… åŠ è¼‰ç¸®åœ–: ${id}`);
          }
        }

        unloadThumbnail(id, itemElement) {
          if (!this.loadedThumbs.has(id)) return; // æœªåŠ è¼‰

          // å¦‚æœæ­£åœ¨æ’­æ”¾å‹•ç•«ï¼Œä¸è¦å¸è¼‰
          if (this.activeState.id === id) return;

          const thumbUrl = this.thumbUrls.get(id);
          if (thumbUrl) {
            URL.revokeObjectURL(thumbUrl);
            this.thumbUrls.delete(id);
          }
          this.loadedThumbs.delete(id);

          // ç§»é™¤åœ–ç‰‡ä½†ä¿ç•™ä½”ä½ç¬¦
          const img = itemElement.querySelector("img");
          if (img) {
            img.src = "";
            itemElement.classList.add("placeholder");
            console.log(`ğŸ—‘ï¸  å¸è¼‰ç¸®åœ–: ${id}`);
          }
        }

        getItemData(id) {
          if (!this.indexMap || !this.indexMap[id]) {
            console.warn(`âš ï¸  é …ç›®ä¸å­˜åœ¨: ${id}`);
            return null;
          }

          return {
            url: this.thumbUrls.get(id),
            width: this.indexMap[id].width,
            height: this.indexMap[id].height,
            type: this.indexMap[id].type || 'webp', // å‘ä¸‹ç›¸å®¹èˆŠç‰ˆ .bin æª”
          };
        }

        getAllIds() {
          return this.indexMap ? Object.keys(this.indexMap) : [];
        }

        handleTap(e) {
          const target = e.target;
          if ((target.tagName !== "IMG" && target.tagName !== "VIDEO") || !target.dataset.id) return;

          // å¦‚æœå‰›å‰›è§¸ç™¼äº†ç§»å‹•é›™æ“Šï¼Œå¿½ç•¥é€™æ¬¡å–®æ“Š
          if (this.justDoubleTapped) {
            this.justDoubleTapped = false;
            return;
          }

          const id = target.dataset.id;

          // æ¸…é™¤ä¹‹å‰çš„å–®æ“Šè¨ˆæ™‚å™¨
          if (this.clickTimer) {
            clearTimeout(this.clickTimer);
            this.clickTimer = null;
          }

          // å»¶é²åŸ·è¡Œå–®æ“Šæ“ä½œï¼ˆçµ¦é›™æ“Šæ©Ÿæœƒï¼‰
          this.clickTimer = setTimeout(() => {
            this.clickTimer = null;
            this.justDoubleTapped = false; // é‡ç½®æ¨™èªŒ
            
            // é»æ“ŠåŒä¸€å€‹æ­£åœ¨æ’­æ”¾çš„ -> åœæ­¢
            if (this.activeState.id === id) {
              console.log(`â¹ï¸  åœæ­¢å‹•ç•«: ${id}`);
              this.stopActiveAnimation();
              return;
            }

            // é»æ“Šæ–°çš„ -> å…ˆåœæ­¢èˆŠçš„ï¼Œå†æ’­æ–°çš„
            if (this.activeState.id) {
              console.log(`â¹ï¸  åœæ­¢å‰ä¸€å€‹å‹•ç•«: ${this.activeState.id}`);
              this.stopActiveAnimation();
            }

            // JIT å»ºç«‹å‹•ç•« Blob
            console.log(`â–¶ï¸  æ’­æ”¾å‹•ç•«: ${id}`);
            this.playAnimation(id, target);
          }, this.clickDelay);
        }

        handleDoubleTap(e) {
          const target = e.target;
          if ((target.tagName !== "IMG" && target.tagName !== "VIDEO") || !target.dataset.id) return;

          // é˜»æ­¢å–®æ“Šäº‹ä»¶åŸ·è¡Œ
          if (this.clickTimer) {
            clearTimeout(this.clickTimer);
            this.clickTimer = null;
          }

          const id = target.dataset.id;
          console.log(`ğŸ–¼ï¸  é›™æ“Šå…¨è¢å¹•: ${id}`);

          // åœæ­¢ç•¶å‰æ’­æ”¾ï¼ˆå¦‚æœæœ‰ï¼‰
          if (this.activeState.id) {
            this.stopActiveAnimation();
          }

          // è§¸ç™¼å…¨è¢å¹•æ¨¡æ…‹æ¡†
          const item = target.closest('.gallery-item');
          if (item) {
            const fullscreenIcon = item.querySelector('.fullscreen-icon');
            if (fullscreenIcon) {
              fullscreenIcon.click();
            }
          }
        }

        handleTouchEnd(e) {
          // ç§»å‹•è¨­å‚™é›™æ“Šæª¢æ¸¬
          const target = e.target;
          if ((target.tagName !== "IMG" && target.tagName !== "VIDEO") || !target.dataset.id) return;

          const currentTime = Date.now();
          const timeDiff = currentTime - this.lastTapTime;

          // æª¢æ¸¬æ˜¯å¦ç‚ºé›™æ“Šï¼ˆ300ms å…§ä¸”åŒä¸€ç›®æ¨™ï¼‰
          if (timeDiff < this.doubleTapDelay && this.lastTapTarget === target) {
            // é€™æ˜¯é›™æ“Šï¼
            e.preventDefault(); // é˜²æ­¢è§¸ç™¼å…¶ä»–äº‹ä»¶
            
            // è¨­ç½®æ¨™èªŒï¼Œé˜²æ­¢å¾ŒçºŒçš„ click äº‹ä»¶è§¸ç™¼å–®æ“Š
            this.justDoubleTapped = true;
            
            // å–æ¶ˆå–®æ“Šè¨ˆæ™‚å™¨
            if (this.clickTimer) {
              clearTimeout(this.clickTimer);
              this.clickTimer = null;
            }

            const id = target.dataset.id;
            console.log(`ğŸ“± ç§»å‹•é›™æ“Šå…¨è¢å¹•: ${id}`);

            // åœæ­¢ç•¶å‰æ’­æ”¾ï¼ˆå¦‚æœæœ‰ï¼‰
            if (this.activeState.id) {
              this.stopActiveAnimation();
            }

            // è§¸ç™¼å…¨è¢å¹•æ¨¡æ…‹æ¡†
            const item = target.closest('.gallery-item');
            if (item) {
              const fullscreenIcon = item.querySelector('.fullscreen-icon');
              if (fullscreenIcon) {
                fullscreenIcon.click();
              }
            }

            // é‡ç½®é›™æ“Šæª¢æ¸¬
            this.lastTapTime = 0;
            this.lastTapTarget = null;
            
            // 500ms å¾Œé‡ç½®æ¨™èªŒï¼ˆé˜²æ­¢å½±éŸ¿ä¸‹æ¬¡é»æ“Šï¼‰
            setTimeout(() => {
              this.justDoubleTapped = false;
            }, 500);
          } else {
            // è¨˜éŒ„é€™æ¬¡é»æ“Š
            this.lastTapTime = currentTime;
            this.lastTapTarget = target;
          }
        }

        playAnimation(id, element) {
          const meta = this.indexMap[id];
          if (!meta) {
            console.warn(`âš ï¸  å‹•ç•«ä¸å­˜åœ¨: ${id}`);
            return;
          }

          const type = meta.type || 'webp';
          
          // å¾ ArrayBuffer åˆ‡å‰²å‹•ç•«è³‡æ–™ (Zero-copy)
          const slice = this.buffer.slice(
            this.payloadStart + meta.anim.offset,
            this.payloadStart + meta.anim.offset + meta.anim.length,
          );

          // æ ¹æ“šé¡å‹å»ºç«‹å°æ‡‰çš„ MIME type
          const mimeTypes = {
            'webp': 'image/webp',
            'gif': 'image/gif',
            'mp4': 'video/mp4'
          };

          // å»ºç«‹ Blob URL
          const animUrl = URL.createObjectURL(
            new Blob([slice], { type: mimeTypes[type] || 'image/webp' }),
          );

          // å–å¾—å®¹å™¨ä¸­çš„ img å’Œ video å…ƒç´ 
          const item = element.closest('.gallery-item');
          const imgEl = item.querySelector('img');
          const videoEl = item.querySelector('video');

          // æ ¹æ“šé¡å‹é¸æ“‡ä½¿ç”¨ img æˆ– video
          if (type === 'mp4') {
            imgEl.style.display = 'none';
            videoEl.style.display = 'block';
            videoEl.src = animUrl;
            videoEl.load();
            videoEl.play();
            this.activeState = { id, element: videoEl, animUrl, type };
            this.animationObserver.observe(videoEl);
          } else {
            videoEl.style.display = 'none';
            imgEl.style.display = 'block';
            imgEl.src = animUrl;
            this.activeState = { id, element: imgEl, animUrl, type };
            this.animationObserver.observe(imgEl);
          }
        }

        stopActiveAnimation() {
          if (!this.activeState.id) return;

          const { id, element, animUrl, type } = this.activeState;

          // åœæ­¢ç›£è½
          this.animationObserver.unobserve(element);

          // å–å¾—å®¹å™¨
          const item = element.closest('.gallery-item');
          if (!item) {
            // å¦‚æœæ‰¾ä¸åˆ°å®¹å™¨ï¼ˆå¯èƒ½å·²è¢«ç§»é™¤ï¼‰ï¼Œåªé‡‹æ”¾ URL
            if (animUrl) {
              URL.revokeObjectURL(animUrl);
            }
            this.activeState = { id: null, element: null, animUrl: null, type: null };
            return;
          }

          const imgEl = item.querySelector('img');
          const videoEl = item.querySelector('video');

          // æ ¹æ“šé¡å‹æ¢å¾©ç¸®åœ–ä¸¦å®Œæ•´æ¸…ç†è³‡æº
          const thumbUrl = this.thumbUrls.get(id);
          if (type === 'mp4' && videoEl) {
            // åœæ­¢è¦–é »ä¸¦å®Œæ•´æ¸…ç†
            videoEl.pause();
            videoEl.removeAttribute('src');
            videoEl.load(); // è§¸ç™¼è³‡æºé‡‹æ”¾
            videoEl.style.display = 'none';
            
            if (thumbUrl && imgEl) {
              imgEl.src = thumbUrl;
              imgEl.style.display = 'block';
            }
          } else {
            if (thumbUrl && imgEl) {
              imgEl.src = thumbUrl;
            }
            if (imgEl) imgEl.style.display = 'block';
            if (videoEl) videoEl.style.display = 'none';
          }

          // é‡‹æ”¾å‹•ç•« Blob URL è¨˜æ†¶é«”ï¼ˆé—œéµ GC æ­¥é©Ÿï¼‰
          if (animUrl) {
            URL.revokeObjectURL(animUrl);
          }

          // é‡ç½®ç‹€æ…‹
          this.activeState = { id: null, element: null, animUrl: null, type: null };
        }

        getAnimationUrl(id) {
          const meta = this.indexMap[id];
          if (!meta) return null;

          const type = meta.type || 'webp';
          const mimeTypes = {
            'webp': 'image/webp',
            'gif': 'image/gif',
            'mp4': 'video/mp4'
          };

          const slice = this.buffer.slice(
            this.payloadStart + meta.anim.offset,
            this.payloadStart + meta.anim.offset + meta.anim.length,
          );

          return URL.createObjectURL(new Blob([slice], { type: mimeTypes[type] || 'image/webp' }));
        }

        dispose() {
          console.log("ğŸ—‘ï¸  æ­£åœ¨éŠ·æ¯€ GalleryEngine...");

          // æ¸…é™¤ä»»ä½•å¾…åŸ·è¡Œçš„å–®æ“Šè¨ˆæ™‚å™¨
          if (this.clickTimer) {
            clearTimeout(this.clickTimer);
            this.clickTimer = null;
          }

          // åœæ­¢ç•¶å‰æ’­æ”¾ä¸¦é‡‹æ”¾è³‡æº
          this.stopActiveAnimation();
          
          // ç§»é™¤æ‰€æœ‰äº‹ä»¶ç›£è½å™¨
          this.container.removeEventListener("click", this.handleTap);
          this.container.removeEventListener("dblclick", this.handleDoubleTap);
          this.container.removeEventListener("touchend", this.handleTouchEnd);
          this.animationObserver.disconnect();
          this.virtualObserver.disconnect();

          // é‡‹æ”¾æ‰€æœ‰ç¸®åœ– URLï¼ˆé—œéµ GC æ­¥é©Ÿï¼‰
          for (const url of this.thumbUrls.values()) {
            URL.revokeObjectURL(url);
          }
          this.thumbUrls.clear();
          this.loadedThumbs.clear();
          
          // æ¸…ç†æ‰€æœ‰ video å…ƒç´ ï¼ˆç¢ºä¿é‡‹æ”¾è¨˜æ†¶é«”ï¼‰
          this.renderedItems.forEach(({ element }) => {
            const videoEl = element.querySelector('video');
            if (videoEl) {
              videoEl.pause();
              videoEl.removeAttribute('src');
              videoEl.load();
            }
          });
          this.renderedItems.clear();

          // æ¸…ç©ºè³‡æ–™ç·©è¡å€å¼•ç”¨
          this.buffer = null;
          this.indexMap = null;
          this.allIds = [];
          this.container.innerHTML = "";

          console.log("âœ… éŠ·æ¯€å®Œæˆ - æ‰€æœ‰è³‡æºå·²é‡‹æ”¾ä¸¦æº–å‚™ GC");
        }
      }

      // ==================== ä¸»æ‡‰ç”¨ç¨‹å¼ ====================
      const galleryContainer = document.getElementById("gallery");
      const uploadSection = document.getElementById("upload-section");
      const loadingEl = document.getElementById("loading");
      const fileInput = document.getElementById("file-input");
      const modal = document.getElementById("modal");
      const modalImg = document.getElementById("modal-img");
      const modalVideo = document.getElementById("modal-video");
      const modalClose = document.getElementById("modal-close");
      const destroyBtn = document.getElementById("destroy-btn");

      let engine = new GalleryEngine(galleryContainer);
      let currentModalUrl = null;

      // é»æ“Šè§£é–è¨ˆæ•¸å™¨
      let clickCount = 0;
      const UNLOCK_CLICKS = 20;
      let unlockHandler = null;

      // è§£é–uploadæŒ‰éˆ•åŠŸèƒ½
      function initUnlockFeature() {
        unlockHandler = () => {
          clickCount++;
          console.log(`ğŸ”’ è§£é–é€²åº¦: ${clickCount}/${UNLOCK_CLICKS}`);
          
          if (clickCount >= UNLOCK_CLICKS) {
            // éš±è—loadingï¼Œé¡¯ç¤ºupload
            loadingEl.style.display = 'none';
            uploadSection.style.display = 'flex';
            
            // ç§»é™¤é»æ“Šç›£è½å™¨
            document.body.removeEventListener('click', unlockHandler);
            unlockHandler = null;
            
            console.log('âœ… å·²è§£é–ä¸Šå‚³åŠŸèƒ½');
          }
        };
        
        document.body.addEventListener('click', unlockHandler);
      }

      // åˆå§‹åŒ–è§£é–åŠŸèƒ½
      initUnlockFeature();

      // æª”æ¡ˆé¸æ“‡äº‹ä»¶
      fileInput.addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        // ç¢ºä¿ç§»é™¤è§£é–ç›£è½å™¨ï¼ˆå¦‚æœé‚„å­˜åœ¨ï¼‰
        if (unlockHandler) {
          document.body.removeEventListener('click', unlockHandler);
          unlockHandler = null;
        }

        uploadSection.style.display = "none";
        loadingEl.style.display = "flex";
        loadingEl.style.cursor = "default"; // æ”¹ç‚ºæ™®é€šé¼ æ¨™

        try {
          await engine.loadFromFile(file);

          loadingEl.style.display = "none";

          // ä½¿ç”¨ console.log è¼¸å‡ºçµ±è¨ˆè³‡è¨Š
          const ids = engine.getAllIds();
          console.log(`âœ… è¼‰å…¥å®Œæˆï¼šå…± ${ids.length} å€‹å‹•ç•«`);
          console.log(
            `ğŸ“Š æª”æ¡ˆå¤§å°ï¼š${(engine.buffer.byteLength / 1024 / 1024).toFixed(2)} MB`,
          );

          // æ¸²æŸ“åœ–åº« (Justified Row Layout)
          renderGallery();

          // é¡¯ç¤ºéŠ·æ¯€æŒ‰éˆ•
          destroyBtn.classList.add("visible");

          // ç›£è½å‹•ç•«ç‹€æ…‹è®ŠåŒ–
          observeActiveState();
        } catch (error) {
          console.error("âŒ è¼‰å…¥å¤±æ•—:", error);
          loadingEl.innerHTML = `
          <div class="error">
            <h3>âŒ æª”æ¡ˆè¼‰å…¥å¤±æ•—</h3>
            <p><strong>éŒ¯èª¤åŸå› ï¼š</strong>${error.message}</p>
            <p style="margin-top: 10px; font-size: 0.9em; opacity: 0.8;">
              è«‹ç¢ºèªæ‚¨ä¸Šå‚³çš„æ˜¯ç”± <code>npm run build</code> ç”¢ç”Ÿçš„æœ‰æ•ˆ .bin æª”æ¡ˆ
            </p>
            <button onclick="location.reload()" style="margin-top: 15px; padding: 10px 20px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: white; border-radius: 5px; cursor: pointer;">
              é‡æ–°è¼‰å…¥
            </button>
          </div>
        `;
        }
      });

      // æ¸²æŸ“åœ–åº« (Justified Row Layout - æŒ‰è¡Œæ¸²æŸ“ï¼Œå»¶é²åŠ è¼‰åœ–ç‰‡)
      function renderGallery() {
        const fragment = document.createDocumentFragment();
        const totalHeight = engine.rows.length > 0 ? 
          engine.rows[engine.rows.length - 1].top + engine.rows[engine.rows.length - 1].height : 0;

        // å‰µå»ºä½”ä½å®¹å™¨ï¼ˆè®“æ»¾å‹•æ¢æ­£ç¢ºé¡¯ç¤ºï¼‰
        const spacer = document.createElement("div");
        spacer.style.height = `${totalHeight}px`;
        spacer.style.position = "relative";
        spacer.id = "gallery-spacer";

        engine.rows.forEach((row, rowIndex) => {
          const rowContainer = document.createElement("div");
          rowContainer.className = "gallery-row";
          rowContainer.dataset.rowIndex = rowIndex;
          rowContainer.style.position = "absolute";
          rowContainer.style.top = `${row.top}px`;
          rowContainer.style.left = "0";
          rowContainer.style.width = "100%";
          rowContainer.style.height = `${row.height}px`;
          rowContainer.style.display = "flex";
          rowContainer.style.gap = `${engine.itemGap}px`;

          row.items.forEach((item) => {
            const itemElement = document.createElement("div");
            itemElement.className = "gallery-item placeholder";
            itemElement.dataset.id = item.id;
            itemElement.style.flex = `0 0 ${item.width}px`;
            itemElement.style.height = `${row.height}px`;
            itemElement.style.position = "relative";

            const img = document.createElement("img");
            img.alt = item.id;
            img.dataset.id = item.id;
            img.style.width = "100%";
            img.style.height = "100%";
            img.style.objectFit = "cover";
            // ä¸è¨­ç½® src - ç­‰å¾… IntersectionObserver è§¸ç™¼åŠ è¼‰

            // ç‚º MP4 æ ¼å¼æ·»åŠ  video å…ƒç´ 
            const video = document.createElement("video");
            video.alt = item.id;
            video.dataset.id = item.id;
            video.loop = true;
            video.muted = true;
            video.playsInline = true;
            video.style.display = 'none';
            video.style.width = "100%";
            video.style.height = "100%";
            video.style.objectFit = "cover";

            // å³ä¸‹è§’å…¨å±åœ–æ¨™
            const fullscreenIcon = document.createElement("div");
            fullscreenIcon.className = "fullscreen-icon";
            fullscreenIcon.innerHTML = `
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>
          </svg>
        `;
            fullscreenIcon.onclick = (e) => {
              e.stopPropagation();
              openModal(item.id);
            };

            itemElement.appendChild(img);
            itemElement.appendChild(video);
            itemElement.appendChild(fullscreenIcon);
            rowContainer.appendChild(itemElement);

            engine.renderedItems.set(item.id, { element: itemElement, isLoaded: false });
          });

          spacer.appendChild(rowContainer);
          
          // é–‹å§‹ç›£è½é€™ä¸€è¡Œï¼ˆè€Œä¸æ˜¯å–®å€‹é …ç›®ï¼‰
          engine.virtualObserver.observe(rowContainer);
          engine.renderedRows.set(rowIndex, { element: rowContainer, isLoaded: false });
        });

        galleryContainer.appendChild(spacer);
        console.log(
          `ğŸ“¦ Justified Layout: å·²å‰µå»º ${engine.rows.length} è¡Œ (å…± ${engine.allIds.length} å€‹é …ç›®ï¼Œåœ–ç‰‡æŒ‰éœ€åŠ è¼‰)`,
        );
      }

      // é–‹å•Ÿå…¨è¢å¹•æ¨¡æ…‹æ¡†
      function openModal(id) {
        const data = engine.getItemData(id);
        if (!data) return;

        // åœæ­¢ç•¶å‰æ’­æ”¾çš„å‹•ç•«
        engine.stopActiveAnimation();

        // å–å¾—å‹•ç•« URL
        currentModalUrl = engine.getAnimationUrl(id);

        // æ ¹æ“šé¡å‹é¸æ“‡é¡¯ç¤ºå…ƒç´ 
        if (data.type === 'mp4') {
          modalImg.style.display = 'none';
          modalVideo.style.display = 'block';
          modalVideo.src = currentModalUrl;
          modalVideo.load();
          modalVideo.play();
        } else {
          modalVideo.style.display = 'none';
          modalImg.style.display = 'block';
          modalImg.src = currentModalUrl;
        }

        modal.classList.add("active");

        console.log(`â–¶ï¸ æ’­æ”¾ï¼š${id} (${data.width} Ã— ${data.height}) [${data.type.toUpperCase()}]`);

        // é˜²æ­¢èƒŒæ™¯æ»¾å‹•
        document.body.style.overflow = "hidden";
      }

      // é—œé–‰æ¨¡æ…‹æ¡†
      function closeModal() {
        modal.classList.remove("active");
        document.body.style.overflow = "";

        // å®Œæ•´åœæ­¢ä¸¦æ¸…ç†è¦–é »æ’­æ”¾ï¼ˆç¢ºä¿ GCï¼‰
        if (modalVideo.src) {
          modalVideo.pause();
          modalVideo.removeAttribute('src');
          modalVideo.load(); // è§¸ç™¼è³‡æºé‡‹æ”¾
        }

        // æ¸…ç†åœ–ç‰‡
        if (modalImg.src) {
          modalImg.src = "";
        }

        // é‡‹æ”¾å‹•ç•« URLï¼ˆé—œéµ GC æ­¥é©Ÿï¼‰
        if (currentModalUrl) {
          URL.revokeObjectURL(currentModalUrl);
          currentModalUrl = null;
        }

        // é‡ç½®é¡¯ç¤ºç‹€æ…‹
        modalImg.style.display = 'none';
        modalVideo.style.display = 'none';

        console.log("â¹ï¸ åœæ­¢æ’­æ”¾ - è³‡æºå·²é‡‹æ”¾");
      }

      modalClose.addEventListener("click", closeModal);
      modal.addEventListener("click", (e) => {
        if (e.target === modal) {
          closeModal();
        }
      });

      // ESC éµé—œé–‰
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && modal.classList.contains("active")) {
          closeModal();
        }
      });

      // éŠ·æ¯€æŒ‰éˆ•äº‹ä»¶
      destroyBtn.addEventListener("click", () => {
        if (
          confirm("ç¢ºå®šè¦éŠ·æ¯€æ‰€æœ‰è³‡æºå—ï¼Ÿæ­¤æ“ä½œå°‡æ¸…ç©ºæ‰€æœ‰æ•¸æ“šä¸¦é‡‹æ”¾è¨˜æ†¶é«”ã€‚")
        ) {
          closeModal();
          engine.dispose();
          engine = new GalleryEngine(galleryContainer);

          // é‡ç½® UI ç‹€æ…‹ï¼ˆä¸é‡æ–°å•Ÿå‹•è§£é–åŠŸèƒ½ï¼‰
          destroyBtn.classList.remove("visible");
          uploadSection.style.display = "flex";
          loadingEl.style.display = "none";
          fileInput.value = ""; // æ¸…ç©ºæ–‡ä»¶é¸æ“‡ï¼Œå…è¨±é‡æ–°é¸æ“‡åŒä¸€æª”æ¡ˆ

          console.log("â™»ï¸  å¼·åˆ¶ GC: æ‰€æœ‰è³‡æºå·²é‡‹æ”¾ï¼Œç­‰å¾…ç€è¦½å™¨åƒåœ¾å›æ”¶...");
        }
      });

      // ç›£è½å‹•ç•«ç‹€æ…‹è®ŠåŒ–
      function observeActiveState() {
        let lastActiveId = null;

        setInterval(() => {
          const currentId = engine.activeState.id;
          if (currentId !== lastActiveId) {
            if (currentId) {
              console.log(`ğŸ¬ ç•¶å‰æ’­æ”¾ï¼š${currentId}`);
            } else {
              console.log("â¸ï¸ ç„¡æ’­æ”¾ä¸­çš„å‹•ç•«");
            }
            lastActiveId = currentId;
          }
        }, 100);
      }

      // é é¢å¸è¼‰æ™‚æ¸…ç†è³‡æºï¼ˆç¢ºä¿æœ€é«˜æ•ˆèƒ½ GCï¼‰
      window.addEventListener("beforeunload", () => {
        // é—œé–‰æ¨¡æ…‹æ¡†ä¸¦æ¸…ç†
        if (modal.classList.contains('active')) {
          closeModal();
        }
        
        // éŠ·æ¯€å¼•æ“ï¼ˆæœƒè‡ªå‹•æ¸…ç†æ‰€æœ‰è³‡æºï¼‰
        engine.dispose();
        
        // é¡å¤–ç¢ºä¿æ¨¡æ…‹æ¡†è³‡æºè¢«é‡‹æ”¾
        if (modalVideo.src) {
          modalVideo.pause();
          modalVideo.removeAttribute('src');
          modalVideo.load();
        }
        if (modalImg.src) {
          modalImg.src = "";
        }
        if (currentModalUrl) {
          URL.revokeObjectURL(currentModalUrl);
          currentModalUrl = null;
        }
        
        console.log("ğŸšª é é¢å¸è¼‰ - æ‰€æœ‰è³‡æºå·²æ¸…ç†");
      });

      // ==================== PWA æ”¯æ´ ====================
      if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          navigator.serviceWorker
            .register("sw.js")
            .then((reg) => console.log("âœ… Service Worker è¨»å†ŠæˆåŠŸ", reg))
            .catch((err) => console.log("âŒ Service Worker è¨»å†Šå¤±æ•—", err));
        });
      }
    </script>
  </body>
</html>
