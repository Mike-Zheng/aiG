<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <meta name="theme-color" content="#37383C" />
    <link rel="manifest" href="manifest.json" />
    <link rel="apple-touch-icon" href="icon-192.png" />
    <title>aiG</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        background: #37383c;
        line-height: 1.6;
        min-height: 100vh;
      }

      .upload-section {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100vh;
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 100;
      }

      .file-input-wrapper {
        position: relative;
        display: inline-block;
      }

      .file-input-wrapper input[type="file"] {
        position: absolute;
        opacity: 0;
        width: 0;
        height: 0;
      }

      .upload-btn {
        display: inline-block;
        padding: 8px 24px;
        background: #4a4b50;
        color: white;
        border-radius: 5px;
        font-size: 10px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .upload-btn:hover {
        background: rgba(255, 255, 255, 0.15);
        transform: translateY(-2px);
      }

      .upload-btn:active {
        transform: translateY(0);
      }

      .destroy-btn {
        position: fixed;
        bottom: 20px;
        left: 10px;
        color: #fff;
        font-size: 14px;
        font-weight: 600;
        z-index: 1000;
        width: 56px;
        height: 56px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        box-sizing: border-box;
        padding: 0;
        border: none;
        text-decoration: none;
        overflow: visible;
        transition:
          box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1),
          opacity 15ms linear 30ms,
          transform 270ms 0ms cubic-bezier(0, 0, 0.2, 1);
        user-select: none;
        cursor: pointer;
        border-radius: 100px;
        background-color: #1a1a1a;
        backdrop-filter: blur(10px);
        display: none;
      }

      .destroy-btn:hover {
        background: rgba(255, 100, 100, 0.3);
        transform: scale(1.05);
      }

      .destroy-btn:active {
        transform: scale(0.95);
      }

      .destroy-btn.visible {
        display: block;
        animation: fadeIn 0.3s ease-out;
      }

      .loading {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100vh;
        align-items: center;
        justify-content: center;
        z-index: 100;
        display: flex;
        cursor: pointer;
      }

      .loading-spinner {
        width: 50px;
        height: 50px;
        margin: 0 auto 20px;
        border: 4px solid rgba(255, 255, 255, 0.1);
        border-top: 4px solid rgba(255, 255, 255, 0.4);
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @keyframes scaleIn {
        from {
          opacity: 0;
          transform: scale(0.9);
        }
        to {
          opacity: 1;
          transform: scale(1);
        }
      }

      #gallery {
        position: relative;
        width: 100%;
        padding: 20px 10px;
        /* margin-top: 50px; */
        min-height: 100vh;
      }

      .gallery-row {
        position: absolute;
        display: flex;
        gap: 5px;
        width: 100%;
      }

      .gallery-item {
        border-radius: 3px;
        overflow: hidden;
        border: 1px solid rgba(255, 255, 255, 0.1);
        transition: all 0.3s ease;
        position: relative;
        cursor: pointer;
        touch-action: manipulation; /* ç¦ç”¨é›™æ“Šç¸®æ”¾ï¼ŒåŠ é€Ÿé›™æ“ŠéŸ¿æ‡‰ */
      }

      .gallery-item.placeholder {
        background: rgba(255, 255, 255, 0.02);
      }

      .gallery-item:nth-child(1) {
        animation-delay: 0.05s;
      }
      .gallery-item:nth-child(2) {
        animation-delay: 0.1s;
      }
      .gallery-item:nth-child(3) {
        animation-delay: 0.15s;
      }
      .gallery-item:nth-child(4) {
        animation-delay: 0.2s;
      }
      .gallery-item:nth-child(5) {
        animation-delay: 0.25s;
      }
      .gallery-item:nth-child(6) {
        animation-delay: 0.3s;
      }
      .gallery-item:nth-child(7) {
        animation-delay: 0.35s;
      }
      .gallery-item:nth-child(8) {
        animation-delay: 0.4s;
      }

      .gallery-item:hover {
        /* transform: translateY(-4px); */
        border-color: rgba(255, 255, 255, 0.2);
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
      }

      .gallery-item img,
      .gallery-item video {
        width: 100%;
        height: auto;
        display: block;
        -webkit-user-select: none;
        user-select: none;
        cursor: pointer;
        transition: transform 0.3s ease;
        touch-action: manipulation; /* ç¦ç”¨é›™æ“Šç¸®æ”¾ï¼ŒåŠ é€Ÿé›™æ“ŠéŸ¿æ‡‰ */
      }

      .gallery-item video {
        display: none;
      }

      .gallery-item:hover img,
      .gallery-item:hover video {
        transform: scale(1.05);
      }

      .fullscreen-icon {
        position: absolute;
        bottom: 5px;
        right: 5px;
        width: 30px;
        height: 30px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
        z-index: 10;
        backdrop-filter: blur(10px);
      }

      .fullscreen-icon:hover {
        background: rgba(0, 0, 0, 0.8);
        transform: scale(1.1);
        border-color: rgba(255, 255, 255, 0.4);
      }

      .fullscreen-icon svg {
        width: 20px;
        height: 20px;
        fill: white;
      }

      .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.95);
        z-index: 9999;
        align-items: center;
        justify-content: center;
        animation: fadeIn 0.3s ease-out;
      }

      .modal.active {
        display: flex;
      }

      .modal-content {
        position: relative;
        max-width: 90vw;
        max-height: 90vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        animation: scaleIn 0.4s ease-out;
      }

      .modal-content img {
        max-width: 100%;
        max-height: 90vh;
        object-fit: contain;
      }

      .modal-close {
        position: absolute;
        top: 20px;
        right: 20px;
        width: 50px;
        height: 50px;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        color: white;
        font-size: 24px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
        z-index: 10000;
      }

      .modal-close:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: rotate(90deg);
      }

      .error {
        background: rgba(255, 100, 100, 0.1);
        border: 2px solid rgba(255, 100, 100, 0.3);
        color: #ff6b6b;
        padding: 30px;
        border-radius: 12px;
        margin: 20px;
        max-width: 500px;
        text-align: center;
      }

      .error h3 {
        margin: 0 0 15px 0;
        font-size: 1.3em;
      }

      .error p {
        margin: 10px 0;
        line-height: 1.6;
      }

      .error code {
        background: rgba(255, 255, 255, 0.1);
        padding: 2px 6px;
        border-radius: 3px;
        font-family: monospace;
      }

      @media (max-width: 600px) {
        .gallery-row {
          gap: 3px;
        }

        .modal-content img {
          max-height: 90vh;
        }

        .modal-close {
          top: 10px;
          right: 10px;
          width: 40px;
          height: 40px;
          font-size: 20px;
        }
      }
    </style>
  </head>
  <body>
    <button class="destroy-btn" id="destroy-btn">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="16"
        height="16"
        viewBox="0 0 16 16"
      >
        <path
          fill="currentColor"
          fill-rule="evenodd"
          d="M5.75 3V1.5h4.5V3zm-1.5 0V1a1 1 0 0 1 1-1h5.5a1 1 0 0 1 1 1v2h2.5a.75.75 0 0 1 0 1.5h-.365l-.743 9.653A2 2 0 0 1 11.148 16H4.852a2 2 0 0 1-1.994-1.847L2.115 4.5H1.75a.75.75 0 0 1 0-1.5zm-.63 1.5h8.76l-.734 9.538a.5.5 0 0 1-.498.462H4.852a.5.5 0 0 1-.498-.462z"
          clip-rule="evenodd"
        />
      </svg>
    </button>

    <div class="upload-section" id="upload-section">
      <div class="file-input-wrapper">
        <input type="file" id="file-input" accept=".bin" />
        <label for="file-input" class="upload-btn">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="20"
            height="20"
            viewBox="0 0 24 24"
          >
            <path
              fill="currentColor"
              d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8zm4 18H6V4h7v5h5z"
            />
          </svg>
        </label>
      </div>
    </div>

    <div class="loading" id="loading">
      <div class="loading-spinner"></div>
    </div>

    <div id="gallery"></div>

    <div class="modal" id="modal">
      <div class="modal-close" id="modal-close">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="24"
          height="24"
          viewBox="0 0 24 24"
        >
          <g
            fill="none"
            stroke="currentColor"
            stroke-dasharray="22"
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="1"
          >
            <path d="M5 5l14 14">
              <animate
                fill="freeze"
                attributeName="stroke-dashoffset"
                dur="0.5s"
                values="22;0"
              />
            </path>
            <path stroke-dashoffset="22" d="M19 5l-14 14">
              <animate
                fill="freeze"
                attributeName="stroke-dashoffset"
                begin="0.5s"
                dur="0.5s"
                to="0"
              />
            </path>
          </g>
        </svg>
      </div>
      <div class="modal-content">
        <img id="modal-img" src="" alt="" style="display: none" />
        <video
          id="modal-video"
          src=""
          loop
          autoplay
          muted
          playsinline
          style="display: none; max-width: 100%; max-height: 90vh"
        ></video>
      </div>
    </div>

    <script>
      // ==================== GalleryEngine æ ¸å¿ƒå¼•æ“ ====================
      class GalleryEngine {
        constructor(containerElement) {
          this.container = containerElement;
          this.buffer = null;
          this.indexMap = null;
          this.payloadStart = 0;

          // BIN æª”æ¡ˆç°½åé…ç½®ï¼ˆéœ€èˆ‡ scripts/bin-signature.json ä¿æŒä¸€è‡´ï¼‰
          this.signatureConfig = {
            secretKey: "aiG-binary-package-secret-key-2026",
            magicNumber: "aiG.BIN",
            version: "1.0.0",
            algorithm: "SHA-256",
          };

          // ç‹€æ…‹ç®¡ç†
          this.thumbUrls = new Map();
          this.activeState = {
            id: null,
            element: null,
            animUrl: null,
            type: null,
          };

          // é»æ“Šå»¶è¿Ÿè¨ˆæ™‚å™¨ï¼ˆé˜²æ­¢å–®æ“Šå’Œé›™æ“Šè¡çªï¼‰
          this.clickTimer = null;
          this.clickDelay = 250; // 250ms å»¶é²

          // ç§»å‹•è¨­å‚™é›™æ“Šæª¢æ¸¬
          this.lastTapTime = 0;
          this.lastTapTarget = null;
          this.doubleTapDelay = 300; // 300ms å…§è¦–ç‚ºé›™æ“Š
          this.justDoubleTapped = false; // æ¨™è¨˜æ˜¯å¦å‰›å‰›é›™æ“Šï¼ˆé˜²æ­¢è§¸ç™¼å–®æ“Šï¼‰

          // Justified Row Layout é…ç½®ï¼ˆéŸ¿æ‡‰å¼èª¿æ•´ï¼‰
          const isMobile = window.innerWidth <= 600;
          this.targetRowHeight = isMobile ? 120 : 200; // ç›®æ¨™è¡Œé«˜ï¼ˆpxï¼‰ï¼šç§»å‹•ç«¯ 120pxï¼Œæ¡Œé¢ 200px
          this.rowGap = isMobile ? 3 : 5; // è¡Œé–“è·ï¼ˆpxï¼‰
          this.itemGap = isMobile ? 3 : 5; // é …ç›®é–“è·ï¼ˆpxï¼‰
          this.paddingX = 10; // å·¦å³ paddingï¼ˆpxï¼‰
          this.paddingY = 20; // ä¸Šä¸‹ paddingï¼ˆpxï¼‰
          this.minItemsPerRow = 3; // æ¯è¡Œæœ€å°é …ç›®æ•¸ï¼ˆå¦‚æœæ•¸é‡è¶³å¤ ï¼‰
          this.containerWidth = 0;

          // Virtual Scroller ç‹€æ…‹ï¼ˆè¡Œç´šåˆ¥ï¼‰
          this.allIds = [];
          this.rows = []; // è¡Œæ•¸æ“šï¼š{items: [{id, width, height}], height, top}
          this.renderedRows = new Map(); // rowIndex -> {element, isLoaded}
          this.renderedItems = new Map(); // id -> {element, isLoaded}
          this.loadedThumbs = new Set(); // å·²åŠ è¼‰çš„ç¸®åœ– ID

          // é›¢é–‹è¦–çª—è‡ªå‹•å›æ”¶æ©Ÿåˆ¶ (é˜² iOS å´©æ½°æ ¸å¿ƒ)
          this.animationObserver = new IntersectionObserver(
            (entries) => {
              entries.forEach((entry) => {
                if (
                  !entry.isIntersecting &&
                  entry.target === this.activeState.imgEl
                ) {
                  this.stopActiveAnimation();
                }
              });
            },
            { threshold: 0 },
          );

          // Virtual Scroller è§€å¯Ÿå™¨ - æŒ‰è¡Œç®¡ç†åœ–ç‰‡çš„åŠ è¼‰èˆ‡å¸è¼‰
          this.virtualObserver = new IntersectionObserver(
            (entries) => {
              entries.forEach((entry) => {
                const rowIndex = parseInt(entry.target.dataset.rowIndex);
                if (isNaN(rowIndex)) return;

                if (entry.isIntersecting) {
                  // é€²å…¥è¦–çª— - åŠ è¼‰é€™ä¸€è¡Œçš„æ‰€æœ‰ç¸®åœ–
                  this.loadRow(rowIndex, entry.target);
                } else {
                  // é›¢é–‹è¦–çª— - å¸è¼‰é€™ä¸€è¡Œçš„æ‰€æœ‰åœ–ç‰‡
                  this.unloadRow(rowIndex, entry.target);
                }
              });
            },
            {
              // æ ¹æ“šè¨­å‚™é¡å‹èª¿æ•´é åŠ è¼‰ç¯„åœ
              rootMargin: window.innerWidth <= 600 ? "300px" : "500px",
              threshold: 0,
            },
          );

          // ç¶å®šäº‹ä»¶ä»£ç†
          this.handleTap = this.handleTap.bind(this);
          this.handleDoubleTap = this.handleDoubleTap.bind(this);
          this.handleTouchEnd = this.handleTouchEnd.bind(this);

          this.container.addEventListener("click", this.handleTap);
          this.container.addEventListener("dblclick", this.handleDoubleTap);
          this.container.addEventListener("touchend", this.handleTouchEnd);
        }

        /**
         * é©—è­‰ BIN æª”æ¡ˆç°½å
         * @param {ArrayBuffer} buffer - BIN æª”æ¡ˆçš„ ArrayBuffer
         * @returns {Promise<Object>} é©—è­‰çµæœ {valid, magic, version, dataStartOffset}
         */
        async verifyBinFile(buffer) {
          const view = new DataView(buffer);
          let offset = 0;

          // æª¢æŸ¥æœ€å°æª”æ¡ˆå¤§å°
          if (buffer.byteLength < 28) {
            throw new Error("æª”æ¡ˆå¤§å°ä¸æ­£ç¢ºï¼Œå¯èƒ½ä¸æ˜¯æœ‰æ•ˆçš„ BIN æª”æ¡ˆ");
          }

          // 1. è®€å– Magic Number (8 bytes)
          const magicBytes = new Uint8Array(buffer, offset, 8);
          const magic = new TextDecoder().decode(magicBytes).replace(/\0/g, "");
          offset += 8;

          if (magic !== this.signatureConfig.magicNumber) {
            throw new Error(
              `ç„¡æ•ˆçš„æª”æ¡ˆæ ¼å¼ï¼é æœŸ: ${this.signatureConfig.magicNumber}, å¯¦éš›: ${magic}`,
            );
          }

          // 2. è®€å– Version (16 bytes)
          const versionBytes = new Uint8Array(buffer, offset, 16);
          const version = new TextDecoder()
            .decode(versionBytes)
            .replace(/\0/g, "");
          offset += 16;

          console.log(`ğŸ“¦ BIN æª”æ¡ˆç‰ˆæœ¬: ${version}`);

          // 3. è®€å–ç°½åé•·åº¦ (4 bytes)
          const signatureLength = view.getUint32(offset, true);
          offset += 4;

          if (signatureLength <= 0 || signatureLength > 1024) {
            throw new Error(`ç°½åé•·åº¦ç•°å¸¸: ${signatureLength}`);
          }

          // 4. è®€å–å„²å­˜çš„ç°½å
          const storedSignature = new Uint8Array(
            buffer,
            offset,
            signatureLength,
          );
          offset += signatureLength;

          // 5. å‰©é¤˜çš„è³‡æ–™å…§å®¹ï¼ˆç”¨æ–¼é©—è­‰ï¼‰
          const dataBuffer = buffer.slice(offset);
          const dataStartOffset = offset;

          // 6. ä½¿ç”¨ Web Crypto API è¨ˆç®— HMAC-SHA256
          console.log("ğŸ” æ­£åœ¨é©—è­‰æª”æ¡ˆç°½å...");
          
          // æª¢æŸ¥ Web Crypto API æ˜¯å¦å¯ç”¨
          if (!window.crypto || !window.crypto.subtle) {
            throw new Error("æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´ Web Crypto APIï¼Œæˆ–ç•¶å‰é é¢ä¸æ˜¯å®‰å…¨ä¸Šä¸‹æ–‡ï¼ˆéœ€è¦ HTTPS æˆ– localhostï¼‰");
          }
          
          const encoder = new TextEncoder();
          const keyData = encoder.encode(this.signatureConfig.secretKey);

          const cryptoKey = await window.crypto.subtle.importKey(
            "raw",
            keyData,
            { name: "HMAC", hash: this.signatureConfig.algorithm },
            false,
            ["sign"],
          );

          const calculatedSignature = await window.crypto.subtle.sign(
            "HMAC",
            cryptoKey,
            dataBuffer,
          );

          // 7. æ¯”è¼ƒç°½å
          const calculated = new Uint8Array(calculatedSignature);

          if (calculated.length !== storedSignature.length) {
            throw new Error("ç°½åé©—è­‰å¤±æ•—ï¼æª”æ¡ˆå¯èƒ½å·²è¢«ç«„æ”¹æˆ–æå£");
          }

          for (let i = 0; i < calculated.length; i++) {
            if (calculated[i] !== storedSignature[i]) {
              throw new Error("ç°½åé©—è­‰å¤±æ•—ï¼æª”æ¡ˆå¯èƒ½å·²è¢«ç«„æ”¹æˆ–æå£");
            }
          }

          console.log("âœ… ç°½åé©—è­‰é€šé");

          return {
            valid: true,
            magic,
            version,
            dataStartOffset,
          };
        }

        async loadFromFile(file) {
          console.log("ğŸ”„ æ­£åœ¨è¼‰å…¥è³‡æ–™åº«...");

          try {
            this.buffer = await file.arrayBuffer();

            // é©—è­‰ BIN æª”æ¡ˆï¼ˆåŒ…å« Magic Number å’Œç°½åæª¢æŸ¥ï¼‰
            const verifyResult = await this.verifyBinFile(this.buffer);

            if (!verifyResult.valid) {
              throw new Error("BIN æª”æ¡ˆé©—è­‰å¤±æ•—");
            }

            console.log(
              `ğŸ“‹ æª”æ¡ˆè³‡è¨Š: ${verifyResult.magic} v${verifyResult.version}`,
            );

            // å¾é©—è­‰å¾Œçš„è³‡æ–™ä½ç½®é–‹å§‹è§£æ
            const dataView = new DataView(
              this.buffer,
              verifyResult.dataStartOffset,
            );

            // è®€å– JSON ç´¢å¼•é•·åº¦ (4 bytes)
            const jsonLength = dataView.getUint32(0, true);

            // è§£æ JSON ç´¢å¼•
            const jsonStr = new TextDecoder().decode(
              new Uint8Array(
                this.buffer,
                verifyResult.dataStartOffset + 4,
                jsonLength,
              ),
            );
            this.indexMap = JSON.parse(jsonStr);

            // è¨ˆç®— Payload èµ·å§‹ä½ç½®ï¼ˆè³‡æ–™èµ·å§‹ + 4 bytes é•·åº¦ + JSON å…§å®¹ï¼‰
            this.payloadStart = verifyResult.dataStartOffset + 4 + jsonLength;

            console.log(
              `âœ… è¼‰å…¥å®Œæˆï¼šå…± ${Object.keys(this.indexMap).length} å€‹é …ç›®`,
            );
            console.log(
              `   è³‡æ–™å¤§å°ï¼š${(this.buffer.byteLength / 1024 / 1024).toFixed(2)} MB`,
            );

            // åˆå§‹åŒ–æ‰€æœ‰ç¸®åœ–
            this.initThumbnails();

            return this.indexMap;
          } catch (error) {
            console.error("âŒ è¼‰å…¥å¤±æ•—:", error);
            throw error;
          }
        }

        /**
         * è¨ˆç®—ä¸€è¡Œçš„æˆæœ¬ï¼ˆé«˜åº¦åå·®ï¼‰
         * æˆæœ¬è¶Šä½ï¼Œä»£è¡¨é«˜åº¦è¶Šæ¥è¿‘ç†æƒ³ç¯„åœï¼ˆåŸºæ–¼ Dijkstra æœ€çŸ­è·¯å¾‘æ€æƒ³ï¼‰
         */
        _getCost(items, startIdx, endIdx) {
          if (startIdx >= endIdx) return Infinity;
          
          const rowItems = items.slice(startIdx, endIdx);
          const gap = this.itemGap;
          
          // è¨ˆç®—é€™ä¸€è¡Œçš„ç¸½å¯¬é«˜æ¯”
          const totalAspectRatio = rowItems.reduce(
            (sum, item) => sum + item.aspectRatio,
            0
          );
          
          // è¨ˆç®—å¯¦éš›é«˜åº¦ï¼ˆå¡«æ»¿å®¹å™¨å¯¬åº¦æ™‚çš„é«˜åº¦ï¼‰
          const availableWidth = this.containerWidth - gap * (rowItems.length - 1);
          const actualHeight = availableWidth / totalAspectRatio;
          
          // ç†æƒ³ç¯„åœï¼šå…è¨± Â±15% å½ˆæ€§
          const minHeight = this.targetRowHeight * 0.85;
          const maxHeight = this.targetRowHeight * 1.15;
          
          // è¨ˆç®—æˆæœ¬ï¼ˆèˆ‡æ–‡æª”ç®—æ³•ä¸€è‡´ï¼‰
          if (actualHeight < minHeight) {
            // å¤ªçŸ®ï¼Œæˆæœ¬ç‚ºå·®è·
            return minHeight - actualHeight;
          } else if (actualHeight > maxHeight) {
            // å¤ªé«˜ï¼Œæˆæœ¬ç‚ºå·®è·
            return actualHeight - maxHeight;
          } else {
            // åœ¨ç¯„åœå…§ï¼Œæˆæœ¬ç‚ºèˆ‡ç›®æ¨™çš„åå·®ï¼ˆæ¬Šé‡é™ä½ï¼‰
            return Math.abs(actualHeight - this.targetRowHeight) * 0.1;
          }
        }

        /**
         * ä½¿ç”¨å‹•æ…‹è¦åŠƒè¨ˆç®—æœ€ä½³åˆ†çµ„
         * åŸºæ–¼ Dijkstra æœ€çŸ­è·¯å¾‘ç®—æ³•ï¼Œæ‰¾å‡ºç¸½æˆæœ¬æœ€ä½çš„åˆ†çµ„æ–¹å¼
         */
        _findOptimalPartition(items) {
          const n = items.length;
          if (n === 0) return [];
          
          const isMobile = window.innerWidth <= 600;
          const minItemsPerRow = this.minItemsPerRow;
          // æœ€å¤§æ¯è¡Œé …ç›®æ•¸ï¼šé¿å…åœ–ç‰‡å¤ªå°
          const maxItemsPerRow = isMobile 
            ? 5 
            : Math.min(8, Math.ceil(this.containerWidth / (this.targetRowHeight * 0.6)));
          
          // dp[i] = åˆ°ç´¢å¼• i ç‚ºæ­¢çš„æœ€å°ç¸½æˆæœ¬
          const dp = new Array(n + 1).fill(Infinity);
          const parent = new Array(n + 1).fill(-1); // è¨˜éŒ„è·¯å¾‘ï¼ˆç”¨æ–¼å›æº¯ï¼‰
          dp[0] = 0;
          
          // å‹•æ…‹è¦åŠƒï¼šå°æ¯å€‹ä½ç½®ï¼Œå˜—è©¦æ‰€æœ‰å¯èƒ½çš„è¡Œåˆ†å‰²
          for (let i = 0; i < n; i++) {
            if (dp[i] === Infinity) continue;
            
            // å˜—è©¦å¾ i é–‹å§‹ï¼Œåˆ° j çµæŸçš„ä¸€è¡Œ
            for (let j = i + minItemsPerRow; j <= Math.min(n, i + maxItemsPerRow); j++) {
              const cost = this._getCost(items, i, j);
              
              if (cost === Infinity) continue;
              
              // æˆæœ¬å¹³æ–¹ï¼Œæ”¾å¤§å·®ç•°ï¼ˆèˆ‡æ–‡æª”ç®—æ³•ä¸€è‡´ï¼‰
              const totalCost = dp[i] + Math.pow(cost, 2);
              
              if (totalCost < dp[j]) {
                dp[j] = totalCost;
                parent[j] = i;
              }
            }
          }
          
          // å›æº¯è·¯å¾‘ï¼Œç²å–æœ€ä½³åˆ†çµ„
          const partition = [];
          let current = n;
          
          while (current > 0 && parent[current] !== -1) {
            partition.unshift({ start: parent[current], end: current });
            current = parent[current];
          }
          
          // å¦‚æœç„¡æ³•å®Œæ•´åˆ†çµ„ï¼ˆç†è«–ä¸Šä¸æœƒç™¼ç”Ÿï¼‰ï¼Œä½¿ç”¨è²ªå¿ƒè£œæ•‘
          if (current !== 0) {
            console.warn('âš ï¸ DP ç„¡æ³•å®Œæ•´åˆ†çµ„ï¼Œä½¿ç”¨è²ªå¿ƒè£œæ•‘');
            partition.unshift({ start: 0, end: current });
          }
          
          console.log(`ğŸ¯ æœ€ä½³åˆ†çµ„ï¼š${partition.length} è¡Œï¼Œç¸½æˆæœ¬ï¼š${dp[n].toFixed(2)}`);
          return partition;
        }

        /**
         * è¨ˆç®— Justified Row Layoutï¼ˆé€²éšç‰ˆï¼‰
         * ä½¿ç”¨å‹•æ…‹è¦åŠƒæ‰¾å‡ºæœ€ä½³è¡Œåˆ†çµ„ï¼Œç¢ºä¿è¦–è¦ºå¹³è¡¡
         * åŸºæ–¼ Dijkstra æœ€çŸ­è·¯å¾‘ç®—æ³•å„ªåŒ–
         */
        calculateRows() {
          // è¨ˆç®—å¯ç”¨å¯¬åº¦
          const fullWidth = this.container.clientWidth || window.innerWidth;
          this.containerWidth = fullWidth - this.paddingX * 2;
          const gap = this.itemGap;

          // æº–å‚™æ•¸æ“šï¼ˆåŒ…å«å¯¬é«˜æ¯”ï¼‰
          const items = [];
          for (const id of this.allIds) {
            const meta = this.indexMap[id];
            if (!meta) continue;
            
            items.push({
              id,
              aspectRatio: meta.width / meta.height,
              meta
            });
          }

          console.log(`ğŸ“ é–‹å§‹è¨ˆç®— Justified Layoutï¼š${items.length} å€‹é …ç›®`);

          // ä½¿ç”¨å‹•æ…‹è¦åŠƒæ‰¾å‡ºæœ€ä½³åˆ†çµ„ï¼ˆæ ¸å¿ƒç®—æ³•ï¼‰
          const partition = this._findOptimalPartition(items);
          
          // æ ¹æ“šåˆ†çµ„ç”Ÿæˆè¡Œæ•¸æ“š
          const rows = [];
          let cumulativeY = 0;

          partition.forEach((part, rowIndex) => {
            const rowItems = items.slice(part.start, part.end);
            
            // è¨ˆç®—é€™ä¸€è¡Œçš„å¯¦éš›é«˜åº¦
            const totalAspectRatio = rowItems.reduce(
              (sum, item) => sum + item.aspectRatio,
              0
            );
            const availableWidth = this.containerWidth - gap * (rowItems.length - 1);
            let actualHeight = availableWidth / totalAspectRatio;
            
            // ç‰¹æ®Šè™•ç†ï¼šé¿å…æœ€å¾Œä¸€è¡Œéé«˜ï¼ˆæ–‡æª”å»ºè­°ï¼‰
            if (rowIndex === partition.length - 1 && rowItems.length < this.minItemsPerRow) {
              actualHeight = Math.min(actualHeight, this.targetRowHeight * 1.1);
            }
            
            rows.push({
              items: rowItems.map(item => ({
                id: item.id,
                width: item.aspectRatio * actualHeight,
                height: actualHeight,
                aspectRatio: item.aspectRatio
              })),
              height: actualHeight,
              top: cumulativeY
            });

            cumulativeY += actualHeight + this.rowGap;
          });

          this.rows = rows;
          
          // çµ±è¨ˆä¿¡æ¯
          const itemCounts = rows.map(r => r.items.length).join(", ");
          const avgHeight = rows.reduce((sum, r) => sum + r.height, 0) / rows.length;
          const heightStdDev = Math.sqrt(
            rows.reduce((sum, r) => sum + Math.pow(r.height - avgHeight, 2), 0) / rows.length
          );
          
          console.log(`âœ“ è¨ˆç®—å®Œæˆï¼š${rows.length} è¡Œï¼Œç¸½é«˜åº¦ ${cumulativeY.toFixed(0)}px`);
          console.log(`ğŸ“Š æ¯è¡Œé …ç›®æ•¸: [${itemCounts}]`);
          console.log(`ğŸ“ é«˜åº¦çµ±è¨ˆ: å¹³å‡ ${avgHeight.toFixed(0)}pxï¼Œæ¨™æº–å·® ${heightStdDev.toFixed(1)}px (ç›®æ¨™: ${this.targetRowHeight}px)`);

          return rows;
        }

        initThumbnails() {
          console.log("ğŸ–¼ï¸  æº–å‚™ Justified Row Layout...");
          this.allIds = Object.keys(this.indexMap);

          // è¨ˆç®—è¡Œå¸ƒå±€
          this.calculateRows();

          console.log(
            `âœ… æº–å‚™å®Œæˆï¼šå…± ${this.allIds.length} å€‹é …ç›®ï¼Œåˆ†ç‚º ${this.rows.length} è¡Œ`,
          );
          console.log(
            `ğŸ“Š Virtual Scroller å·²å•Ÿç”¨ - åœ–ç‰‡å°‡æŒ‰éœ€åŠ è¼‰`,
          );
        }

        /**
         * ç²å–ç•¶å‰å…§å­˜çµ±è¨ˆ
         */
        getMemoryStats() {
          return {
            totalItems: this.allIds.length,
            loadedThumbs: this.loadedThumbs.size,
            activeRows: Array.from(this.renderedRows.values()).filter(r => r.isLoaded).length,
            totalRows: this.rows.length,
            loadPercentage: ((this.loadedThumbs.size / this.allIds.length) * 100).toFixed(1),
          };
        }

        /**
         * åŠ è¼‰ä¸€æ•´è¡Œçš„æ‰€æœ‰ç¸®åœ–
         */
        loadRow(rowIndex, rowElement) {
          const row = this.rows[rowIndex];
          if (!row) return;

          // æª¢æŸ¥è¡Œç‹€æ…‹ï¼Œé¿å…é‡è¤‡åŠ è¼‰
          const rowState = this.renderedRows.get(rowIndex);
          if (rowState && rowState.isLoaded) return;

          let loadedCount = 0;
          row.items.forEach((item) => {
            const id = item.id;
            if (this.loadedThumbs.has(id)) return;

            const meta = this.indexMap[id];
            if (!meta) return;

            const slice = this.buffer.slice(
              this.payloadStart + meta.thumb.offset,
              this.payloadStart + meta.thumb.offset + meta.thumb.length,
            );
            const thumbUrl = URL.createObjectURL(
              new Blob([slice], { type: "image/webp" }),
            );
            this.thumbUrls.set(id, thumbUrl);
            this.loadedThumbs.add(id);

            // æ›´æ–° DOM
            const itemElement = rowElement.querySelector(`[data-id="${id}"]`);
            const img = itemElement?.querySelector("img");
            if (img) {
              img.src = thumbUrl;
              itemElement.classList.remove("placeholder");
              loadedCount++;
            }
          });

          // æ¨™è¨˜é€™ä¸€è¡Œå·²åŠ è¼‰
          if (rowState) {
            rowState.isLoaded = true;
          }

          if (loadedCount > 0) {
            console.log(`âœ… åŠ è¼‰ç¬¬ ${rowIndex} è¡Œ (${loadedCount}/${row.items.length} å€‹é …ç›®)`);
          }
        }

        /**
         * å¸è¼‰ä¸€æ•´è¡Œçš„æ‰€æœ‰ç¸®åœ–
         */
        unloadRow(rowIndex, rowElement) {
          const row = this.rows[rowIndex];
          if (!row) return;

          // æª¢æŸ¥è¡Œç‹€æ…‹ï¼Œé¿å…é‡è¤‡å¸è¼‰
          const rowState = this.renderedRows.get(rowIndex);
          if (rowState && !rowState.isLoaded) return;

          let unloadedCount = 0;
          row.items.forEach((item) => {
            const id = item.id;
            if (!this.loadedThumbs.has(id)) return;
            if (this.activeState.id === id) return; // æ­£åœ¨æ’­æ”¾çš„ä¸å¸è¼‰

            const thumbUrl = this.thumbUrls.get(id);
            if (thumbUrl) {
              URL.revokeObjectURL(thumbUrl);
              this.thumbUrls.delete(id);
            }
            this.loadedThumbs.delete(id);

            const itemElement = rowElement.querySelector(`[data-id="${id}"]`);
            const img = itemElement?.querySelector("img");
            if (img) {
              img.src = "";
              itemElement.classList.add("placeholder");
              unloadedCount++;
            }
          });

          // æ¨™è¨˜é€™ä¸€è¡Œå·²å¸è¼‰
          if (rowState) {
            rowState.isLoaded = false;
          }

          if (unloadedCount > 0) {
            console.log(`ğŸ—‘ï¸  å¸è¼‰ç¬¬ ${rowIndex} è¡Œ (${unloadedCount}/${row.items.length} å€‹é …ç›®)`);
          }
        }

        loadThumbnail(id, itemElement) {
          if (this.loadedThumbs.has(id)) return; // å·²åŠ è¼‰

          const meta = this.indexMap[id];
          if (!meta) return;

          const slice = this.buffer.slice(
            this.payloadStart + meta.thumb.offset,
            this.payloadStart + meta.thumb.offset + meta.thumb.length,
          );
          const thumbUrl = URL.createObjectURL(
            new Blob([slice], { type: "image/webp" }),
          );
          this.thumbUrls.set(id, thumbUrl);
          this.loadedThumbs.add(id);

          // æ›´æ–° DOM
          const img = itemElement.querySelector("img");
          if (img) {
            img.src = thumbUrl;
            itemElement.classList.remove("placeholder");
            console.log(`âœ… åŠ è¼‰ç¸®åœ–: ${id}`);
          }
        }

        unloadThumbnail(id, itemElement) {
          if (!this.loadedThumbs.has(id)) return; // æœªåŠ è¼‰

          // å¦‚æœæ­£åœ¨æ’­æ”¾å‹•ç•«ï¼Œä¸è¦å¸è¼‰
          if (this.activeState.id === id) return;

          const thumbUrl = this.thumbUrls.get(id);
          if (thumbUrl) {
            URL.revokeObjectURL(thumbUrl);
            this.thumbUrls.delete(id);
          }
          this.loadedThumbs.delete(id);

          // ç§»é™¤åœ–ç‰‡ä½†ä¿ç•™ä½”ä½ç¬¦
          const img = itemElement.querySelector("img");
          if (img) {
            img.src = "";
            itemElement.classList.add("placeholder");
            console.log(`ğŸ—‘ï¸  å¸è¼‰ç¸®åœ–: ${id}`);
          }
        }

        getItemData(id) {
          if (!this.indexMap || !this.indexMap[id]) {
            console.warn(`âš ï¸  é …ç›®ä¸å­˜åœ¨: ${id}`);
            return null;
          }

          return {
            url: this.thumbUrls.get(id),
            width: this.indexMap[id].width,
            height: this.indexMap[id].height,
            type: this.indexMap[id].type || "webp", // å‘ä¸‹ç›¸å®¹èˆŠç‰ˆ .bin æª”
          };
        }

        getAllIds() {
          return this.indexMap ? Object.keys(this.indexMap) : [];
        }

        handleTap(e) {
          const target = e.target;
          if (
            (target.tagName !== "IMG" && target.tagName !== "VIDEO") ||
            !target.dataset.id
          )
            return;

          // å¦‚æœå‰›å‰›è§¸ç™¼äº†ç§»å‹•é›™æ“Šï¼Œå¿½ç•¥é€™æ¬¡å–®æ“Š
          if (this.justDoubleTapped) {
            this.justDoubleTapped = false;
            return;
          }

          const id = target.dataset.id;

          // æ¸…é™¤ä¹‹å‰çš„å–®æ“Šè¨ˆæ™‚å™¨
          if (this.clickTimer) {
            clearTimeout(this.clickTimer);
            this.clickTimer = null;
          }

          // å»¶é²åŸ·è¡Œå–®æ“Šæ“ä½œï¼ˆçµ¦é›™æ“Šæ©Ÿæœƒï¼‰
          this.clickTimer = setTimeout(() => {
            this.clickTimer = null;
            this.justDoubleTapped = false; // é‡ç½®æ¨™èªŒ

            // é»æ“ŠåŒä¸€å€‹æ­£åœ¨æ’­æ”¾çš„ -> åœæ­¢
            if (this.activeState.id === id) {
              console.log(`â¹ï¸  åœæ­¢å‹•ç•«: ${id}`);
              this.stopActiveAnimation();
              return;
            }

            // é»æ“Šæ–°çš„ -> å…ˆåœæ­¢èˆŠçš„ï¼Œå†æ’­æ–°çš„
            if (this.activeState.id) {
              console.log(`â¹ï¸  åœæ­¢å‰ä¸€å€‹å‹•ç•«: ${this.activeState.id}`);
              this.stopActiveAnimation();
            }

            // JIT å»ºç«‹å‹•ç•« Blob
            console.log(`â–¶ï¸  æ’­æ”¾å‹•ç•«: ${id}`);
            this.playAnimation(id, target);
          }, this.clickDelay);
        }

        handleDoubleTap(e) {
          const target = e.target;
          if (
            (target.tagName !== "IMG" && target.tagName !== "VIDEO") ||
            !target.dataset.id
          )
            return;

          // é˜»æ­¢å–®æ“Šäº‹ä»¶åŸ·è¡Œ
          if (this.clickTimer) {
            clearTimeout(this.clickTimer);
            this.clickTimer = null;
          }

          const id = target.dataset.id;
          console.log(`ğŸ–¼ï¸  é›™æ“Šå…¨è¢å¹•: ${id}`);

          // åœæ­¢ç•¶å‰æ’­æ”¾ï¼ˆå¦‚æœæœ‰ï¼‰
          if (this.activeState.id) {
            this.stopActiveAnimation();
          }

          // è§¸ç™¼å…¨è¢å¹•æ¨¡æ…‹æ¡†
          const item = target.closest(".gallery-item");
          if (item) {
            const fullscreenIcon = item.querySelector(".fullscreen-icon");
            if (fullscreenIcon) {
              fullscreenIcon.click();
            }
          }
        }

        handleTouchEnd(e) {
          // ç§»å‹•è¨­å‚™é›™æ“Šæª¢æ¸¬
          const target = e.target;
          if (
            (target.tagName !== "IMG" && target.tagName !== "VIDEO") ||
            !target.dataset.id
          )
            return;

          const currentTime = Date.now();
          const timeDiff = currentTime - this.lastTapTime;

          // æª¢æ¸¬æ˜¯å¦ç‚ºé›™æ“Šï¼ˆ300ms å…§ä¸”åŒä¸€ç›®æ¨™ï¼‰
          if (timeDiff < this.doubleTapDelay && this.lastTapTarget === target) {
            // é€™æ˜¯é›™æ“Šï¼
            e.preventDefault(); // é˜²æ­¢è§¸ç™¼å…¶ä»–äº‹ä»¶

            // è¨­ç½®æ¨™èªŒï¼Œé˜²æ­¢å¾ŒçºŒçš„ click äº‹ä»¶è§¸ç™¼å–®æ“Š
            this.justDoubleTapped = true;

            // å–æ¶ˆå–®æ“Šè¨ˆæ™‚å™¨
            if (this.clickTimer) {
              clearTimeout(this.clickTimer);
              this.clickTimer = null;
            }

            const id = target.dataset.id;
            console.log(`ğŸ“± ç§»å‹•é›™æ“Šå…¨è¢å¹•: ${id}`);

            // åœæ­¢ç•¶å‰æ’­æ”¾ï¼ˆå¦‚æœæœ‰ï¼‰
            if (this.activeState.id) {
              this.stopActiveAnimation();
            }

            // è§¸ç™¼å…¨è¢å¹•æ¨¡æ…‹æ¡†
            const item = target.closest(".gallery-item");
            if (item) {
              const fullscreenIcon = item.querySelector(".fullscreen-icon");
              if (fullscreenIcon) {
                fullscreenIcon.click();
              }
            }

            // é‡ç½®é›™æ“Šæª¢æ¸¬
            this.lastTapTime = 0;
            this.lastTapTarget = null;

            // 500ms å¾Œé‡ç½®æ¨™èªŒï¼ˆé˜²æ­¢å½±éŸ¿ä¸‹æ¬¡é»æ“Šï¼‰
            setTimeout(() => {
              this.justDoubleTapped = false;
            }, 500);
          } else {
            // è¨˜éŒ„é€™æ¬¡é»æ“Š
            this.lastTapTime = currentTime;
            this.lastTapTarget = target;
          }
        }

        playAnimation(id, element) {
          const meta = this.indexMap[id];
          if (!meta) {
            console.warn(`âš ï¸  å‹•ç•«ä¸å­˜åœ¨: ${id}`);
            return;
          }

          const type = meta.type || "webp";

          // å¾ ArrayBuffer åˆ‡å‰²å‹•ç•«è³‡æ–™ (Zero-copy)
          const slice = this.buffer.slice(
            this.payloadStart + meta.anim.offset,
            this.payloadStart + meta.anim.offset + meta.anim.length,
          );

          // æ ¹æ“šé¡å‹å»ºç«‹å°æ‡‰çš„ MIME type
          const mimeTypes = {
            webp: "image/webp",
            gif: "image/gif",
            mp4: "video/mp4",
          };

          // å»ºç«‹ Blob URL
          const animUrl = URL.createObjectURL(
            new Blob([slice], { type: mimeTypes[type] || "image/webp" }),
          );

          // å–å¾—å®¹å™¨ä¸­çš„ img å’Œ video å…ƒç´ 
          const item = element.closest(".gallery-item");
          const imgEl = item.querySelector("img");
          const videoEl = item.querySelector("video");

          // æ ¹æ“šé¡å‹é¸æ“‡ä½¿ç”¨ img æˆ– video
          if (type === "mp4") {
            imgEl.style.display = "none";
            videoEl.style.display = "block";
            videoEl.src = animUrl;
            videoEl.load();
            videoEl.play();
            this.activeState = { id, element: videoEl, animUrl, type };
            this.animationObserver.observe(videoEl);
          } else {
            videoEl.style.display = "none";
            imgEl.style.display = "block";
            imgEl.src = animUrl;
            this.activeState = { id, element: imgEl, animUrl, type };
            this.animationObserver.observe(imgEl);
          }
        }

        stopActiveAnimation() {
          if (!this.activeState.id) return;

          const { id, element, animUrl, type } = this.activeState;

          // åœæ­¢ç›£è½
          this.animationObserver.unobserve(element);

          // å–å¾—å®¹å™¨
          const item = element.closest(".gallery-item");
          if (!item) {
            // å¦‚æœæ‰¾ä¸åˆ°å®¹å™¨ï¼ˆå¯èƒ½å·²è¢«ç§»é™¤ï¼‰ï¼Œåªé‡‹æ”¾ URL
            if (animUrl) {
              URL.revokeObjectURL(animUrl);
            }
            this.activeState = {
              id: null,
              element: null,
              animUrl: null,
              type: null,
            };
            return;
          }

          const imgEl = item.querySelector("img");
          const videoEl = item.querySelector("video");

          // æ ¹æ“šé¡å‹æ¢å¾©ç¸®åœ–ä¸¦å®Œæ•´æ¸…ç†è³‡æº
          const thumbUrl = this.thumbUrls.get(id);
          if (type === "mp4" && videoEl) {
            // åœæ­¢è¦–é »ä¸¦å®Œæ•´æ¸…ç†
            videoEl.pause();
            videoEl.removeAttribute("src");
            videoEl.load(); // è§¸ç™¼è³‡æºé‡‹æ”¾
            videoEl.style.display = "none";

            if (thumbUrl && imgEl) {
              imgEl.src = thumbUrl;
              imgEl.style.display = "block";
            }
          } else {
            if (thumbUrl && imgEl) {
              imgEl.src = thumbUrl;
            }
            if (imgEl) imgEl.style.display = "block";
            if (videoEl) videoEl.style.display = "none";
          }

          // é‡‹æ”¾å‹•ç•« Blob URL è¨˜æ†¶é«”ï¼ˆé—œéµ GC æ­¥é©Ÿï¼‰
          if (animUrl) {
            URL.revokeObjectURL(animUrl);
          }

          // é‡ç½®ç‹€æ…‹
          this.activeState = {
            id: null,
            element: null,
            animUrl: null,
            type: null,
          };
        }

        getAnimationUrl(id) {
          const meta = this.indexMap[id];
          if (!meta) return null;

          const type = meta.type || "webp";
          const mimeTypes = {
            webp: "image/webp",
            gif: "image/gif",
            mp4: "video/mp4",
          };

          const slice = this.buffer.slice(
            this.payloadStart + meta.anim.offset,
            this.payloadStart + meta.anim.offset + meta.anim.length,
          );

          return URL.createObjectURL(
            new Blob([slice], { type: mimeTypes[type] || "image/webp" }),
          );
        }

        dispose() {
          console.log("ğŸ—‘ï¸  æ­£åœ¨éŠ·æ¯€ GalleryEngine...");

          // æ¸…é™¤ä»»ä½•å¾…åŸ·è¡Œçš„å–®æ“Šè¨ˆæ™‚å™¨
          if (this.clickTimer) {
            clearTimeout(this.clickTimer);
            this.clickTimer = null;
          }

          // åœæ­¢ç•¶å‰æ’­æ”¾ä¸¦é‡‹æ”¾è³‡æº
          this.stopActiveAnimation();

          // ç§»é™¤æ‰€æœ‰äº‹ä»¶ç›£è½å™¨
          this.container.removeEventListener("click", this.handleTap);
          this.container.removeEventListener("dblclick", this.handleDoubleTap);
          this.container.removeEventListener("touchend", this.handleTouchEnd);
          this.animationObserver.disconnect();
          this.virtualObserver.disconnect();

          // é‡‹æ”¾æ‰€æœ‰ç¸®åœ– URLï¼ˆé—œéµ GC æ­¥é©Ÿï¼‰
          for (const url of this.thumbUrls.values()) {
            URL.revokeObjectURL(url);
          }
          this.thumbUrls.clear();
          this.loadedThumbs.clear();

          // æ¸…ç†æ‰€æœ‰ video å…ƒç´ ï¼ˆç¢ºä¿é‡‹æ”¾è¨˜æ†¶é«”ï¼‰
          this.renderedItems.forEach(({ element }) => {
            const videoEl = element.querySelector("video");
            if (videoEl) {
              videoEl.pause();
              videoEl.removeAttribute("src");
              videoEl.load();
            }
          });
          this.renderedItems.clear();

          // æ¸…ç©ºè³‡æ–™ç·©è¡å€å¼•ç”¨
          this.buffer = null;
          this.indexMap = null;
          this.allIds = [];
          this.container.innerHTML = "";

          console.log("âœ… éŠ·æ¯€å®Œæˆ - æ‰€æœ‰è³‡æºå·²é‡‹æ”¾ä¸¦æº–å‚™ GC");
        }
      }

      // ==================== ä¸»æ‡‰ç”¨ç¨‹å¼ ====================
      const galleryContainer = document.getElementById("gallery");
      const uploadSection = document.getElementById("upload-section");
      const loadingEl = document.getElementById("loading");
      const fileInput = document.getElementById("file-input");
      const modal = document.getElementById("modal");
      const modalImg = document.getElementById("modal-img");
      const modalVideo = document.getElementById("modal-video");
      const modalClose = document.getElementById("modal-close");
      const destroyBtn = document.getElementById("destroy-btn");

      let engine = new GalleryEngine(galleryContainer);
      let currentModalUrl = null;

      // é»æ“Šè§£é–è¨ˆæ•¸å™¨
      let clickCount = 0;
      const UNLOCK_CLICKS = 20;
      let unlockHandler = null;

      // è§£é–uploadæŒ‰éˆ•åŠŸèƒ½
      function initUnlockFeature() {
        unlockHandler = () => {
          clickCount++;
          console.log(`ğŸ”’ è§£é–é€²åº¦: ${clickCount}/${UNLOCK_CLICKS}`);

          if (clickCount >= UNLOCK_CLICKS) {
            // éš±è—loadingï¼Œé¡¯ç¤ºupload
            loadingEl.style.display = "none";
            uploadSection.style.display = "flex";

            // ç§»é™¤é»æ“Šç›£è½å™¨
            document.body.removeEventListener("click", unlockHandler);
            unlockHandler = null;

            console.log("âœ… å·²è§£é–ä¸Šå‚³åŠŸèƒ½");
          }
        };

        document.body.addEventListener("click", unlockHandler);
      }

      // åˆå§‹åŒ–è§£é–åŠŸèƒ½
      initUnlockFeature();

      // æª”æ¡ˆé¸æ“‡äº‹ä»¶
      fileInput.addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        // ç¢ºä¿ç§»é™¤è§£é–ç›£è½å™¨ï¼ˆå¦‚æœé‚„å­˜åœ¨ï¼‰
        if (unlockHandler) {
          document.body.removeEventListener("click", unlockHandler);
          unlockHandler = null;
        }

        uploadSection.style.display = "none";
        loadingEl.style.display = "flex";
        loadingEl.style.cursor = "default"; // æ”¹ç‚ºæ™®é€šé¼ æ¨™

        try {
          await engine.loadFromFile(file);

          loadingEl.style.display = "none";

          // ä½¿ç”¨ console.log è¼¸å‡ºçµ±è¨ˆè³‡è¨Š
          const ids = engine.getAllIds();
          console.log(`âœ… è¼‰å…¥å®Œæˆï¼šå…± ${ids.length} å€‹å‹•ç•«`);
          console.log(
            `ğŸ“Š æª”æ¡ˆå¤§å°ï¼š${(engine.buffer.byteLength / 1024 / 1024).toFixed(2)} MB`,
          );

          // æ¸²æŸ“åœ–åº« (Justified Row Layout)
          renderGallery();

          // é¡¯ç¤ºéŠ·æ¯€æŒ‰éˆ•
          destroyBtn.classList.add("visible");

          // ç›£è½å‹•ç•«ç‹€æ…‹è®ŠåŒ–
          observeActiveState();
        } catch (error) {
          console.error("âŒ è¼‰å…¥å¤±æ•—:", error);
          loadingEl.innerHTML = `
          <div class="error">
            <h3>âŒ æª”æ¡ˆè¼‰å…¥å¤±æ•—</h3>
            <p><strong>éŒ¯èª¤åŸå› ï¼š</strong>${error.message}</p>
            <p style="margin-top: 10px; font-size: 0.9em; opacity: 0.8;">
              è«‹ç¢ºèªæ‚¨ä¸Šå‚³çš„æ˜¯ç”± <code>npm run build</code> ç”¢ç”Ÿçš„æœ‰æ•ˆ .bin æª”æ¡ˆ
            </p>
            <button onclick="location.reload()" style="margin-top: 15px; padding: 10px 20px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: white; border-radius: 5px; cursor: pointer;">
              é‡æ–°è¼‰å…¥
            </button>
          </div>
        `;
        }
      });

      // æ¸²æŸ“åœ–åº« (Justified Row Layout - æŒ‰è¡Œæ¸²æŸ“ï¼Œå»¶é²åŠ è¼‰åœ–ç‰‡)
      function renderGallery() {
        const fragment = document.createDocumentFragment();
        const totalHeight =
          engine.rows.length > 0
            ? engine.rows[engine.rows.length - 1].top +
              engine.rows[engine.rows.length - 1].height
            : 0;

        // å‰µå»ºä½”ä½å®¹å™¨ï¼ˆè®“æ»¾å‹•æ¢æ­£ç¢ºé¡¯ç¤ºï¼‰
        const spacer = document.createElement("div");
        spacer.style.height = `${totalHeight}px`;
        spacer.style.position = "relative";
        spacer.id = "gallery-spacer";

        engine.rows.forEach((row, rowIndex) => {
          const rowContainer = document.createElement("div");
          rowContainer.className = "gallery-row";
          rowContainer.dataset.rowIndex = rowIndex;
          rowContainer.style.position = "absolute";
          rowContainer.style.top = `${row.top}px`;
          rowContainer.style.left = "0";
          rowContainer.style.width = "100%";
          rowContainer.style.height = `${row.height}px`;
          rowContainer.style.display = "flex";
          rowContainer.style.gap = `${engine.itemGap}px`;

          row.items.forEach((item) => {
            const itemElement = document.createElement("div");
            itemElement.className = "gallery-item placeholder";
            itemElement.dataset.id = item.id;
            itemElement.style.flex = `0 0 ${item.width}px`;
            itemElement.style.height = `${row.height}px`;
            itemElement.style.position = "relative";

            const img = document.createElement("img");
            img.alt = item.id;
            img.dataset.id = item.id;
            img.style.width = "100%";
            img.style.height = "100%";
            img.style.objectFit = "cover";
            // ä¸è¨­ç½® src - ç­‰å¾… IntersectionObserver è§¸ç™¼åŠ è¼‰

            // ç‚º MP4 æ ¼å¼æ·»åŠ  video å…ƒç´ 
            const video = document.createElement("video");
            video.alt = item.id;
            video.dataset.id = item.id;
            video.loop = true;
            video.muted = true;
            video.playsInline = true;
            video.style.display = "none";
            video.style.width = "100%";
            video.style.height = "100%";
            video.style.objectFit = "cover";

            // å³ä¸‹è§’å…¨å±åœ–æ¨™
            const fullscreenIcon = document.createElement("div");
            fullscreenIcon.className = "fullscreen-icon";
            fullscreenIcon.innerHTML = `
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>
          </svg>
        `;
            fullscreenIcon.onclick = (e) => {
              e.stopPropagation();
              openModal(item.id);
            };

            itemElement.appendChild(img);
            itemElement.appendChild(video);
            itemElement.appendChild(fullscreenIcon);
            rowContainer.appendChild(itemElement);

            engine.renderedItems.set(item.id, {
              element: itemElement,
              isLoaded: false,
            });
          });

          spacer.appendChild(rowContainer);

          // é–‹å§‹ç›£è½é€™ä¸€è¡Œï¼ˆè€Œä¸æ˜¯å–®å€‹é …ç›®ï¼‰
          engine.virtualObserver.observe(rowContainer);
          engine.renderedRows.set(rowIndex, {
            element: rowContainer,
            isLoaded: false,
          });
        });

        galleryContainer.appendChild(spacer);
        console.log(
          `ğŸ“¦ Justified Layout: å·²å‰µå»º ${engine.rows.length} è¡Œ (å…± ${engine.allIds.length} å€‹é …ç›®ï¼Œåœ–ç‰‡æŒ‰éœ€åŠ è¼‰)`,
        );
      }

      // é–‹å•Ÿå…¨è¢å¹•æ¨¡æ…‹æ¡†
      function openModal(id) {
        const data = engine.getItemData(id);
        if (!data) return;

        // åœæ­¢ç•¶å‰æ’­æ”¾çš„å‹•ç•«
        engine.stopActiveAnimation();

        // å–å¾—å‹•ç•« URL
        currentModalUrl = engine.getAnimationUrl(id);

        // æ ¹æ“šé¡å‹é¸æ“‡é¡¯ç¤ºå…ƒç´ 
        if (data.type === "mp4") {
          modalImg.style.display = "none";
          modalVideo.style.display = "block";
          modalVideo.src = currentModalUrl;
          modalVideo.load();
          modalVideo.play();
        } else {
          modalVideo.style.display = "none";
          modalImg.style.display = "block";
          modalImg.src = currentModalUrl;
        }

        modal.classList.add("active");

        console.log(
          `â–¶ï¸ æ’­æ”¾ï¼š${id} (${data.width} Ã— ${data.height}) [${data.type.toUpperCase()}]`,
        );

        // é˜²æ­¢èƒŒæ™¯æ»¾å‹•
        document.body.style.overflow = "hidden";
      }

      // é—œé–‰æ¨¡æ…‹æ¡†
      function closeModal() {
        modal.classList.remove("active");
        document.body.style.overflow = "";

        // å®Œæ•´åœæ­¢ä¸¦æ¸…ç†è¦–é »æ’­æ”¾ï¼ˆç¢ºä¿ GCï¼‰
        if (modalVideo.src) {
          modalVideo.pause();
          modalVideo.removeAttribute("src");
          modalVideo.load(); // è§¸ç™¼è³‡æºé‡‹æ”¾
        }

        // æ¸…ç†åœ–ç‰‡
        if (modalImg.src) {
          modalImg.src = "";
        }

        // é‡‹æ”¾å‹•ç•« URLï¼ˆé—œéµ GC æ­¥é©Ÿï¼‰
        if (currentModalUrl) {
          URL.revokeObjectURL(currentModalUrl);
          currentModalUrl = null;
        }

        // é‡ç½®é¡¯ç¤ºç‹€æ…‹
        modalImg.style.display = "none";
        modalVideo.style.display = "none";

        console.log("â¹ï¸ åœæ­¢æ’­æ”¾ - è³‡æºå·²é‡‹æ”¾");
      }

      modalClose.addEventListener("click", closeModal);
      modal.addEventListener("click", (e) => {
        if (e.target === modal) {
          closeModal();
        }
      });

      // ESC éµé—œé–‰
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && modal.classList.contains("active")) {
          closeModal();
        }
      });

      // éŠ·æ¯€æŒ‰éˆ•äº‹ä»¶
      destroyBtn.addEventListener("click", () => {
        if (
          confirm("ç¢ºå®šè¦éŠ·æ¯€æ‰€æœ‰è³‡æºå—ï¼Ÿæ­¤æ“ä½œå°‡æ¸…ç©ºæ‰€æœ‰æ•¸æ“šä¸¦é‡‹æ”¾è¨˜æ†¶é«”ã€‚")
        ) {
          closeModal();
          engine.dispose();
          engine = new GalleryEngine(galleryContainer);

          // é‡ç½® UI ç‹€æ…‹ï¼ˆä¸é‡æ–°å•Ÿå‹•è§£é–åŠŸèƒ½ï¼‰
          destroyBtn.classList.remove("visible");
          uploadSection.style.display = "flex";
          loadingEl.style.display = "none";
          fileInput.value = ""; // æ¸…ç©ºæ–‡ä»¶é¸æ“‡ï¼Œå…è¨±é‡æ–°é¸æ“‡åŒä¸€æª”æ¡ˆ

          console.log("â™»ï¸  å¼·åˆ¶ GC: æ‰€æœ‰è³‡æºå·²é‡‹æ”¾ï¼Œç­‰å¾…ç€è¦½å™¨åƒåœ¾å›æ”¶...");
        }
      });

      // ç›£è½å‹•ç•«ç‹€æ…‹è®ŠåŒ–å’Œå…§å­˜çµ±è¨ˆ
      function observeActiveState() {
        let lastActiveId = null;
        let statsCounter = 0;

        setInterval(() => {
          const currentId = engine.activeState.id;
          if (currentId !== lastActiveId) {
            if (currentId) {
              console.log(`ğŸ¬ ç•¶å‰æ’­æ”¾ï¼š${currentId}`);
            } else {
              console.log("â¸ï¸ ç„¡æ’­æ”¾ä¸­çš„å‹•ç•«");
            }
            lastActiveId = currentId;
          }

          // æ¯ 50 æ¬¡å¾ªç’°ï¼ˆ5 ç§’ï¼‰è¼¸å‡ºä¸€æ¬¡å…§å­˜çµ±è¨ˆ
          statsCounter++;
          if (statsCounter >= 50) {
            const stats = engine.getMemoryStats();
            console.log(
              `ğŸ“Š Virtual Scroller çµ±è¨ˆ: ${stats.loadedThumbs}/${stats.totalItems} å·²åŠ è¼‰ (${stats.loadPercentage}%) | ${stats.activeRows}/${stats.totalRows} è¡Œå¯è¦‹`,
            );
            statsCounter = 0;
          }
        }, 100);
      }

      // é é¢å¸è¼‰æ™‚æ¸…ç†è³‡æºï¼ˆç¢ºä¿æœ€é«˜æ•ˆèƒ½ GCï¼‰
      window.addEventListener("beforeunload", () => {
        // é—œé–‰æ¨¡æ…‹æ¡†ä¸¦æ¸…ç†
        if (modal.classList.contains("active")) {
          closeModal();
        }

        // éŠ·æ¯€å¼•æ“ï¼ˆæœƒè‡ªå‹•æ¸…ç†æ‰€æœ‰è³‡æºï¼‰
        engine.dispose();

        // é¡å¤–ç¢ºä¿æ¨¡æ…‹æ¡†è³‡æºè¢«é‡‹æ”¾
        if (modalVideo.src) {
          modalVideo.pause();
          modalVideo.removeAttribute("src");
          modalVideo.load();
        }
        if (modalImg.src) {
          modalImg.src = "";
        }
        if (currentModalUrl) {
          URL.revokeObjectURL(currentModalUrl);
          currentModalUrl = null;
        }

        console.log("ğŸšª é é¢å¸è¼‰ - æ‰€æœ‰è³‡æºå·²æ¸…ç†");
      });

      // ==================== èª¿è©¦å·¥å…· ====================
      // æä¾›å…¨å±€å‡½æ•¸ä¾›é–‹ç™¼è€…ä½¿ç”¨
      window.getMemoryStats = () => {
        const stats = engine.getMemoryStats();
        console.log("ğŸ“Š Virtual Scroller è©³ç´°çµ±è¨ˆ:");
        console.log(`  ç¸½é …ç›®æ•¸: ${stats.totalItems}`);
        console.log(`  å·²åŠ è¼‰ç¸®åœ–: ${stats.loadedThumbs} (${stats.loadPercentage}%)`);
        console.log(`  å¯è¦‹è¡Œæ•¸: ${stats.activeRows}/${stats.totalRows}`);
        console.log(`  å…§å­˜ç¯€çœ: ${(100 - parseFloat(stats.loadPercentage)).toFixed(1)}%`);
        
        // å¦‚æœç€è¦½å™¨æ”¯æ´ï¼Œé¡¯ç¤ºå¯¦éš›å…§å­˜ä½¿ç”¨
        if (performance.memory) {
          const usedMB = (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(2);
          const totalMB = (performance.memory.totalJSHeapSize / 1024 / 1024).toFixed(2);
          console.log(`  JS å †å…§å­˜: ${usedMB}MB / ${totalMB}MB`);
        }
        
        return stats;
      };

      // æç¤ºé–‹ç™¼è€…å¯ç”¨çš„èª¿è©¦å‘½ä»¤
      console.log("ğŸ’¡ èª¿è©¦å‘½ä»¤: åœ¨æ§åˆ¶å°è¼¸å…¥ getMemoryStats() æŸ¥çœ‹è©³ç´°çµ±è¨ˆ");


      // ==================== PWA æ”¯æ´ ====================
      if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          navigator.serviceWorker
            .register("sw.js")
            .then((reg) => console.log("âœ… Service Worker è¨»å†ŠæˆåŠŸ", reg))
            .catch((err) => console.log("âŒ Service Worker è¨»å†Šå¤±æ•—", err));
        });
      }
    </script>
  </body>
</html>
